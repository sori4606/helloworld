# SRAM, DDR2의 Write, Read 동작방식

## 목차

- [SRAM의 구조](./sram동작.md#sram의-구조)
- [SRAM의 Read 동작](./sram동작.md#sram의-read-동작)
- [SRAM의 Write 동작](./sram동작.md#sram의-write-동작)
- [DDR2의 구조](./sram동작.md#ddr2-구조)
- [DDR2의 Read 동작](./sram동작.md#ddr2-read-동작)
- [DDR2의 Write 동작](./sram동작.md#ddr2의-write-동작)
- [용어설명](./sram동작.md#용어-설명)
- [SRAM, DRAM 쉬운 설명](./sram동작.md#sram-dram-비유로-쉽게-이해하기)


## SARM 의 Read/Write 방식

그 전에, SRAM , DRAM의 Read/Write 방식을 비유로 쉽게 이해하고 싶다면 ? -> [이동하기](./sram동작.md#sram-dram-비유로-쉽게-이해하기)

### SRAM의 구조
: SRAM은 6개의 트랜지스터로 구성된 [비트셀](./sram동작.md#1-비트셀-bit-cell--메모리에서-1비트의-데이터를-저장하는-최소-단위-회로)을 사용한다. 두 개의 [인버터](./sram동작.md#2-인버터-inverter--입력-신호를-반전시키는-기본-논리-게이트)가 교차 결합되어 [래치](./sram동작.md#3-래치-latch--데이터를-저장하고-유지하는-회로)를 형성하고, 2개의 [액세스 트랜지스터](./sram동작.md#4-액세스-트랜지스터-access-transistor)가 [워드라인(WL)](./sram동작.md#5-워드라인-word-line-wl)으로 제어됨.

### SRAM의 Read 동작

1. 프리차지 단계

    - [비트라인(BL)](./sram동작.md#6-비트라인bl-반전-비트라인blb)과 [반전 비트라인(BLB)](./sram동작.md#6-비트라인bl-반전-비트라인blb)을 [VDD](./sram동작.md#7-vdd)로 [프리차지](./sram동작.md#8-프리차지-precharge)
    - [이퀄라이저](./sram동작.md#9-이퀄라이저-equalizer)로 두 라인을 동일 전압으로 맞춤

2. 워드라인 활성화

    - 선택된 워드라인을 HIGH로 구동
    - 액세스 트랜지스터 2개가 ON 상태로 전환

3. 비트라인 디벨롭

    - 셀에 저장된 데이터가 '0'이면 BL이 방전되고 BLB는 HIGH 유지
    - 셀에 저장된 데이터가 '1'이면 BLB가 방전되고 BL은 HIGH 유지
    - [센스 앰프](./sram동작.md#10-센스-앰프-sense-amplifier)가 BL과 BLB의 미세한 전압 차이를 감지하여 증폭

4. 데이터 출력

    - 센스 앰프의 출력이 데이터 버스로 전달

### SRAM의 Write 동작

1. 워드라인 활성화

    - 쓰기 대상 셀의 워드라인을 HIGH로 구동
    - 액세스 트랜지스터가 활성화

2. 비트라인 구동

    - 쓸 데이터가 '1'이면: BL = VDD, BLB = 0V
    - 쓸 데이터가 '0'이면: BL = 0V, BLB = VDD
    - [라이트 드라이버](./sram동작.md#20-라이트-드라이버-write-driver)가 비트라인을 강하게 구동

3. 셀 상태 반전

    - 비트라인의 강한 구동력이 셀 내부 래치의 상태를 강제로 반전
    - 교차 결합된 인버터의 피드백이 새로운 상태를 안정화


4. 완료

    - 워드라인을 비활성화하면 새로운 데이터가 셀에 유지됨


## DDR2 의 Read/Write 방식

### DDR2 구조

- DRAM 셀: 1개의 트랜지스터 + 1개의 커패시터(1T1C)
- [프리페치 버퍼](./sram동작.md#11-프리페치-버퍼-prefetch-buffer): 4비트 (DDR은 2비트)
- 클럭의 상승/하강 엣지 모두에서 데이터 전송

###  DDR2 Read 동작

1. 활성화(Activation) 단계

    - READ 명령 전에 ACTIVE 명령 필요
    - [로우 어드레스(RAS)](./sram동작.md#12-로우-어드레스-row-address)로 특정 행 선택
    - 선택된 워드라인이 활성화되면 해당 행의 모든 셀이 센스 앰프로 데이터 전송
    - 커패시터의 전하가 비트라인으로 흐르며 미세한 전압 변화 발생

2. 센스 증폭

    - 센스 앰프가 비트라인의 미세한 전압 차이를 감지
    - [차동 증폭](./sram동작.md#13-차동-증폭-differential-amplification)으로 [FULL CMOS](./sram동작.md#14-full-cmos-레벨) 레벨(0V 또는 VDD)로 복원
    - [파괴적 읽기](./sram동작.md#22-파괴적-읽기-destructive-read): 읽기 과정에서 커패시터 전하가 손실되므로 센스 앰프가 원래 값을 다시 써줌


3. 컬럼 액세스

    - READ 명령과 함께 [컬럼 어드레스(CAS)](./sram동작.md#15-컬럼-어드레스-column-address) 입력
    - 컬럼 디코더가 특정 비트 선택
    - 4비트 프리페치: 연속된 4비트를 내부 버퍼에 일시 저장

4. 데이터 출력

    - [CAS 레이턴시(CL)](./sram동작.md#16-cas-레이턴시-cas-latency-cl) 후 데이터 출력 시작
    - DDR2는 클럭의 상승/하강 엣지마다 2비트씩 출력
    - 총 2클럭 사이클에 걸쳐 4비트 전송 (4 burst)

5. 프리차지

    - READ 완료 후 PRECHARGE 명령으로 비트라인 초기화
    - 다음 액세스 준비

### DDR2의 Write 동작

1. 활성화 단계

    - ACTIVE 명령으로 특정 행을 센스 앰프로 오픈
    - 읽기와 동일하게 워드라인 활성화

2. 라이트 명령

    - WRITE 명령과 컬럼 어드레스 입력
    - [DQS(Data Strobe)](./sram동작.md#17-dqs-data-strobe) 신호와 함께 데이터 입력 시작

3. 데이터 입력

    - 클럭의 상승/하강 엣지에 맞춰 [DQ 핀](./sram동작.md#18-dq-핀-data-inputoutput-pin)으로 데이터 입력
    - DQS 신호가 데이터의 중앙을 샘플링하는 타이밍 제공
    - 4비트 프리페치 버퍼에 데이터 저장


4. 실제 쓰기

    - 입력된 데이터가 [컬럼 디코더](./sram동작.md#19-컬럼-디코더-column-decoder)를 통해 선택된 비트라인으로 전달
    - [라이트 드라이버](./sram동작.md#20-라이트-드라이버-write-driver)가 비트라인을 강하게 구동
    - 센스 앰프를 통해 DRAM 셀의 커패시터로 전하 저장
    - 커패시터 충전 여부로 '1' 또는 '0' 저장


5. 프리차지

    - 쓰기 완료 후 tWR(Write Recovery Time) 이후 [PRECHARGE](./sram동작.md#21-precharge) 가능


## 용어 설명

### 1. 비트셀 (Bit Cell) : 메모리에서 1비트의 데이터를 저장하는 최소 단위 회로

- SRAM : 6개의 트랜지스터로 구성 (6T cell)
- DRAM : 1개의 트랜지스터 + 1개의 커패시터 (1T1C cell)

### 2. 인버터 (Inverter) : 입력 신호를 반전시키는 기본 논리 게이트

- 입력이 HIGH(1) → 출력은 LOW(0)
- 입력이 LOW(0) → 출력은 HIGH(1)
- SRAM에서는 2개의 인버터가 교차 연결되어 데이터 저장

### 3. 래치 (Latch) : 데이터를 저장하고 유지하는 회로

- 두 개의 인버터를 교차 결합(cross-coupled)하여 구성
- 피드백 구조로 안정적인 두 상태(0 또는 1)를 유지

### 4. 액세스 트랜지스터 (Access Transistor)
메모리 셀과 비트라인을 **연결/차단하는 스위치** 역할.
- 워드라인으로 제어됨
- ON: 셀의 데이터를 읽거나 쓸 수 있음
- OFF: 셀이 비트라인으로부터 격리됨

### 5. 워드라인 (Word Line, WL)
**특정 행(row)의 메모리 셀들을 선택**하는 수평 신호선.
- 행 디코더(Row Decoder)로 구동
- 워드라인이 활성화되면 해당 행의 모든 액세스 트랜지스터가 ON
- 한 번에 하나의 워드라인만 활성화

### 6. 비트라인(BL), 반전 비트라인(BLB)
**데이터를 전송하는 수직 신호선**.
- **BL (Bit Line)**: 정상 비트라인
- **BLB (Bit Line Bar)**: 반전 비트라인 (보수 신호)
- SRAM에서는 차동 신호로 사용하여 노이즈 내성 향상
- 읽기 시: 미세한 전압 차이 발생
- 쓰기 시: 데이터 전달 경로
```
     BL0   BL1   BL2   BL3  (수직 - 비트라인들)
      |     |     |     |
WL0 ──●─────●─────●─────●── (수평 - 워드라인)
      |셀0  |셀1  |셀2  |셀3
WL1 ──●─────●─────●─────●──
      |셀4  |셀5  |셀6  |셀7
WL2 ──●─────●─────●─────●──
      |셀8  |셀9  |셀10 |셀11

● = 메모리 셀 (워드라인과 비트라인의 교차점)
```

### 7. VDD
**전원 공급 전압**.
- 일반적으로 1.2V, 1.5V, 1.8V, 3.3V 등
- 디지털 회로의 논리 HIGH 레벨
- VSS 또는 GND는 0V (기준 전압)

**VSS (Voltage Source Source)**

- 0V 기준 전압을 나타내는 반도체 회로 용어
- 트랜지스터의 소스(Source) 단자가 연결되는 전압
- 회로 설계에서 사용하는 공식 용어

**GND (Ground)**

- 접지, 0V 기준점
- 일반적인 전자 회로에서 사용하는 용어
- 실제 물리적인 대지 접지를 의미할 수도 있음

**관계**

VSS = GND = 0V (논리적으로 같음)

```
전원 구조:
VDD ──────┐
          │ (전원 전압)
         회로
          │
VSS/GND ──┘ (기준 전압, 0V)
```

**사용 구분:**
- **VSS**: 회로도, 데이터시트에서 주로 사용 (formal)
- **GND**: 실무, PCB 설계에서 주로 사용 (practical)
- 기능적으로는 동일


### 8. 프리차지 (Precharge)
읽기/쓰기 동작 전에 **비트라인을 초기 전압으로 충전**하는 과정.
- 일반적으로 VDD 또는 VDD/2로 충전
- 다음 동작을 위한 준비 단계
- 빠른 센싱을 위해 필요

**과정:**
```
프리차지 → 워드라인 활성화 → 읽기/쓰기 → 프리차지
```

### 9. 이퀄라이저 (Equalizer)
**BL과 BLB를 같은 전압으로 맞춰주는 회로**.
- 프리차지와 함께 동작
- 두 비트라인 사이의 전압 차이를 0으로 만듦
- 정확한 센싱을 위한 초기 조건 설정

### 10. 센스 앰프 (Sense Amplifier)
**비트라인의 미세한 전압 차이를 감지하고 증폭**하는 회로.

**읽기 시:**
- BL과 BLB 사이의 수십~수백 mV 차이를 감지
- FULL CMOS 레벨(0V 또는 VDD)로 증폭
- 고속 읽기 가능

### 11. 프리페치 버퍼 (Prefetch Buffer)
**내부에서 여러 비트를 미리 읽어 임시 저장**하는 버퍼.
- DDR: 2비트 프리페치
- DDR2: 4비트 프리페치
- DDR3: 8비트 프리페치
- 내부는 느리게 동작하고 외부로는 빠르게 전송
- 버스트(Burst) 전송 지원

### 12. 로우 어드레스 (Row Address)
메모리 배열에서 **행(row)을 선택하는 어드레스**.
- RAS (Row Address Strobe) 신호와 함께 입력
- 행 디코더가 해석하여 특정 워드라인 활성화
- ACTIVE 명령 시 사용

### 13. 차동 증폭 (Differential Amplification)
**두 신호의 차이를 증폭**하는 방식.
- 센스 앰프에서 사용
- 장점:
  - 노이즈 제거 (공통 모드 노이즈 상쇄)
  - 미세한 신호 감지 가능
  - 빠른 동작
- BL과 BLB의 전압 차이만 증폭

### 14. FULL CMOS 레벨
디지털 신호의 **완전한 논리 레벨**.
- **LOW**: 0V (GND)
- **HIGH**: VDD (예: 1.2V, 1.8V)
- 중간 값이 아닌 확실한 0 또는 1 상태
- 노이즈 마진이 크고 신뢰성 높음

### 15. 컬럼 어드레스 (Column Address)
메모리 배열에서 **열(column)을 선택하는 어드레스**.
- CAS (Column Address Strobe) 신호와 함께 입력
- 컬럼 디코더가 해석
- READ/WRITE 명령 시 사용
- 활성화된 행 내에서 특정 비트 선택

**메모리 액세스:**
```
1. 로우 어드레스 → 행 선택
2. 컬럼 어드레스 → 열 선택
3. 교차점의 셀 액세스
```

### 16. CAS 레이턴시 (CAS Latency, CL)
READ 명령 후 **데이터가 실제로 출력되기까지의 클럭 사이클 수**.
- 예: CL=5 → READ 명령 후 5 클럭 후 데이터 출력
- 센스 증폭, 프리페치, 출력 버퍼 지연 시간 포함
- 낮을수록 빠름 (CL=3이 CL=5보다 빠름)
- DDR2: 일반적으로 CL=3, 4, 5

### 17. DQS (Data Strobe)
**데이터 전송 타이밍을 맞추는 신호**.
- 양방향 신호 (읽기/쓰기 모두 사용)
- 데이터(DQ)와 함께 전송
- **Source Synchronous**: 데이터 송신 측에서 클럭도 함께 전송
- DQS의 엣지가 데이터의 중앙을 가리킴
- 고속 전송 시 클럭 스큐 문제 해결

### **문제: 시스템 클럭 사용 시**
```
시스템 클럭:  ___/‾‾‾\___/‾‾‾\___
데이터(DQ):   ====[D0]====[D1]====
샘플링:         ↑         ↑
             (엣지에서 샘플링)
```

### **샘플링** ? : 특정 시점에 신호의 값을 읽어서 저장하는 동작

**문제점:**
- 고속 동작 시 신호 전파 지연(skew) 발생
- 데이터와 클럭이 동기화 안 됨
- 엣지에서 샘플링하면 데이터 전환 중에 읽을 수 있음 → 에러!

### **해결: DQS (Data Strobe)**
```
DQS:      ____/‾‾‾\___/‾‾‾\___/‾‾‾\____
DQ:       =====[D0]====[D1]====[D2]=====
          
샘플링:        ↑       ↑       ↑
            (DQS 엣지 = 데이터 중앙)
```

**핵심:**
- DQS의 **상승/하강 엣지**가 데이터의 **안정된 중앙 구간**을 가리킴
- 데이터가 완전히 안정된 시점에 샘플링
- 데이터 전환 시점을 피함

### **클럭 스큐 (Clock Skew)란?**

**정의**: 클럭 신호가 서로 다른 소자에 도달하는 시간 차이
```
               메모리 컨트롤러
                     |
         시스템 클럭 발생
                     |
        +------------+------------+
        |                         |
   (지연: 2ns)               (지연: 3ns)
        |                         |
    메모리 칩1               메모리 칩2
    
클럭1: ___/‾‾‾\___          
클럭2: ____/‾‾‾\___  ← 1ns 스큐 발생!
```

### **스큐 발생 원인**

1. **PCB 배선 길이 차이**
   - 컨트롤러 → 메모리1: 10cm
   - 컨트롤러 → 메모리2: 15cm
   - 전파 속도: ~17cm/ns → 차이 발생

2. **부하 차이**
   - 여러 메모리 칩이 한 클럭 라인에 연결
   - 부하에 따라 신호 지연 달라짐

3. **온도/전압 변화**
   - 동작 조건에 따라 지연 시간 변화

### **고속에서 문제가 심각한 이유**
```
저속 (DDR-400, 클럭 주기 5ns):
클럭:  _____/‾‾‾‾‾\______/‾‾‾‾‾\______
         5ns              5ns
스큐 1ns: 20%의 여유 ← 괜찮음

고속 (DDR3-1600, 클럭 주기 1.25ns):
클럭:  _/‾‾\___/‾‾\___
      1.25ns  1.25ns
스큐 1ns: 80% 손실! ← 심각!
```

### **DQS가 스큐 문제를 해결하는 방법**

#### **기존 방식: 공통 클럭 (Common Clock)**
```
컨트롤러 ─── 시스템 클럭 ────→ 메모리
         ─── 데이터(DQ) ─────→

문제: 클럭과 데이터가 다른 경로로 전송
→ 스큐 발생!
```

#### **DQS 방식: Source Synchronous**
```
컨트롤러 ─┬─ 데이터(DQ) ──→ 메모리
          └─ DQS ────────→

핵심: 데이터 송신 측에서 타이밍 신호(DQS)도 함께 전송
→ 같은 경로, 같은 지연!
```

### 18. DQ 핀 (Data Input/Output Pin)
**실제 데이터가 입출력되는 핀**.
- DQ0, DQ1, DQ2, ... DQ7 (8비트 모듈)
- 또는 DQ0~DQ63 (64비트 모듈)
- 양방향 핀 (Bidirectional)
- DQS 신호와 함께 동작

### 모듈

**정의** <br />
여러 개의 메모리 칩을 하나의 **PCB(인쇄회로기판)에 실장한 조립품**.

### **메모리 모듈의 종류**

#### **1. DIMM (Dual Inline Memory Module)**
```
+-------------------------------------------+
|  [칩] [칩] [칩] [칩] [칩] [칩] [칩] [칩]  |
|                                           |
|  [칩] [칩] [칩] [칩] [칩] [칩] [칩] [칩]  |
+-------------------------------------------+
         앞면 8개 + 뒷면 8개 = 총 16개
```

- **데스크톱, 서버용**
- 240핀 (DDR2/DDR3), 288핀 (DDR4/DDR5)
- 양면에 핀이 독립적 (Dual Inline)
- 64비트 데이터 버스

#### **2. SO-DIMM (Small Outline DIMM)**
```
+---------------------------+
|  [칩] [칩] [칩] [칩]      |
|                           |
|  [칩] [칩] [칩] [칩]      |
+---------------------------+
      노트북용 (작은 크기)
```

- **노트북, 임베디드 시스템용**
- 작은 폼팩터
- 260핀 (DDR4)

#### **3. RDIMM (Registered DIMM)**
```
+-------------------------------------------+
|       [레지스터 칩]                       |
|  [칩] [칩] [칩] [칩] [칩] [칩] [칩] [칩]  |
+-------------------------------------------+
```

- **서버용 고용량 메모리**
- 레지스터(버퍼)로 신호 증폭/재생
- 더 많은 모듈 장착 가능
- 레이턴시 1 클럭 증가

### 19. 컬럼 디코더 (Column Decoder)
**컬럼 어드레스를 해석하여 특정 열을 선택**하는 회로.
- 컬럼 어드레스 입력 → 디코딩
- 컬럼 선택 신호 생성
- 멀티플렉서를 제어하여 데이터 경로 선택
- 센스 앰프의 출력 중 필요한 비트만 선택

### 20. 라이트 드라이버 (Write Driver)
**쓰기 시 비트라인을 강하게 구동**하는 회로.
- 입력 데이터를 받아 BL/BLB로 전송
- 셀의 상태를 바꿀 수 있을 만큼 강한 전류 공급
- 일반적으로 센스 앰프보다 구동력이 큼
- SRAM: 래치 상태 반전
- DRAM: 커패시터 충전/방전

### 21. PRECHARGE
**비트라인과 메모리 뱅크를 초기 상태로 되돌리는 명령/동작**.

**역할:**
- 활성화된 행을 닫음 (워드라인 비활성화)
- 비트라인을 VDD 또는 VDD/2로 충전
- 다음 ACTIVE 명령 준비

**종류:**
- **Manual Precharge**: 명시적 PRECHARGE 명령
- **Auto Precharge**: READ/WRITE 후 자동 프리차지

**타이밍:**
- tRP (RAS Precharge Time): 프리차지 완료까지의 시간
- 프리차지 완료 후에만 새로운 ACTIVE 명령 가능
```
ACTIVE → READ/WRITE → PRECHARGE → ACTIVE (다음 행)
   ↑                      ↑
  행 오픈             행 닫기 + 초기화
```


### 22. 파괴적 읽기 (Destructive Read)

### **개념**
DRAM에서 **데이터를 읽는 과정에서 원본 데이터가 파괴되는 현상**.

### **왜 발생하는가?**

**DRAM 셀 구조:**
```
워드라인(WL) ──┤ 게이트
비트라인(BL) ──┤ 드레인
               │ 소스
               │
              [C] ← 커패시터 (데이터 저장)
               │
              GND
```

**읽기 과정:**
1. **읽기 전**: 커패시터에 전하 충전됨 (예: 1.2V = '1' 저장)
2. **워드라인 활성화**: 트랜지스터 ON
3. **전하 공유**: 커패시터의 전하가 비트라인으로 흐름
4. **문제**: 커패시터 용량 << 비트라인 용량
   - 커패시터: ~30fF (펨토패럿 (정전용량의 매우 작은 단위))
   - 비트라인: ~200fF
   - 전하가 비트라인으로 퍼지면서 **커패시터 전압 감소**
```
읽기 전:
커패시터: 1.2V ████████
비트라인: 0.6V (프리차지)

읽기 후:
커패시터: 0.7V ████     ← 전하 손실!
비트라인: 0.65V (미세하게 상승)
```

### **해결 방법: Write-back (재기입)**
```
1. 센스 앰프가 미세한 전압 차이 감지 (0.05V)
2. FULL CMOS 레벨로 증폭 (0V 또는 1.2V)
3. 증폭된 신호를 다시 셀로 되돌림 (Write-back)
4. 커패시터에 원래 전하 복원
```

**전체 과정:**
```
프리차지 → 워드라인 활성화 → 전하 공유(파괴) 
→ 센스 증폭 → Write-back(복원) → 프리차지
```

## SRAM, DRAM 비유로 쉽게 이해하기

SRAM 셀 = 두 개의 시소가 연결된 구조


```
시소1 ⇄ 시소2
        
한쪽이 올라가면 → 다른쪽은 내려감
한쪽이 내려가면 → 다른쪽은 올라감

이 상태가 계속 유지됨 = 데이터 저장!
```

## SRAM 셀의 실제 모습 (단순화)
```
     전원(VDD, 1.2V)
          |
      [시소 구조]
      올림 ⇄ 내림
       Q     QB
       |      |
    [문1]  [문2]  ← 워드라인이 열쇠
       |      |
      BL    BLB   ← 데이터 통로
```

**상태 저장:**
- Q가 올라감(HIGH) ↔ QB는 내려감(LOW) = '1' 저장
- Q가 내려감(LOW) ↔ QB는 올라감(HIGH) = '0' 저장

---

# SRAM Read 과정 🔍

## 준비 단계: 프리차지
```
[1단계] 읽기 전 준비

BL과 BLB를 중간 높이로 채움
(물통에 물을 절반씩 채우는 것과 같음)

BL:  [====물====]  ← 1.2V로 충전
BLB: [====물====]  ← 1.2V로 충전

목적: 미세한 변화를 감지하기 위해
```

## Read 과정

### **시나리오: '1'이 저장된 셀 읽기**
```
저장된 상태:
Q = HIGH (1.2V) = '1'
QB = LOW (0V) = '0'
```

**[2단계] 워드라인 활성화 = 문 열기**
```
워드라인 ON!
    ↓
  [문1]  [문2] 열림!
    |      |
   BL    BLB
```

**[3단계] 데이터가 비트라인으로 흘러나옴**
```
셀 내부:
Q(HIGH) → 문1 열림 → BL로 흐름
QB(LOW) → 문2 열림 → BLB에서 빠져나감

비트라인의 미세한 변화:
BL:  [=====물=====]  1.2V (그대로)
                ↑ Q가 HIGH라서 유지

BLB: [====물====]   1.15V (약간 감소)
              ↓ QB가 LOW라서 약간 빠짐
```

**[4단계] 센스 앰프 = 탐정의 돋보기**
```
센스 앰프가 미세한 차이 발견!

BL:  1.20V  }
BLB: 1.15V  } → 차이 0.05V 발견!

센스 앰프: "BL이 더 높네? 그럼 '1'이다!"

증폭! (확실하게 만들기)
BL:  → 1.2V (HIGH)
BLB: → 0V (LOW)

결과: '1' 읽음! ✓
```

### **그림으로 보는 Read**
```
[읽기 전]
워드라인: ────── (문 잠김)
BL:  [====]  1.2V
BLB: [====]  1.2V
셀: Q=HIGH, QB=LOW

     ↓ 워드라인 ON

[읽는 중]
워드라인: ━━━━━━ (문 열림!)
BL:  [====]  1.20V ← Q(HIGH)가 연결
BLB: [===]   1.15V ← QB(LOW)가 연결
        ↓ 미세한 차이!

     ↓ 센스 앰프 동작

[읽기 완료]
출력: '1' ✓
```

---

# SRAM Write 과정 ✍️

## Write 과정

### **시나리오: '0'을 쓰려고 함**
```
현재 셀 상태:
Q = HIGH (1.2V) = '1'
QB = LOW (0V) = '0'

목표: '0'으로 바꾸기!
```

**[1단계] 비트라인에 데이터 준비**
```
'0'을 쓰려면:
BL = LOW (0V)
BLB = HIGH (1.2V)

BL:  [    ] 0V    ← 물을 비움
BLB: [====] 1.2V  ← 물을 가득 채움
```

**[2단계] 워드라인 활성화 = 문 열기**
```
워드라인 ON!
    ↓
  [문1]  [문2] 열림!
    |      |
   BL    BLB
```

**[3단계] 강제로 상태 뒤집기!**
```
셀 내부 (원래):
Q = HIGH (1.2V)
QB = LOW (0V)

비트라인이 강력하게 밀어붙임:
BL(0V)가 Q를 끌어내림! 💪
BLB(1.2V)가 QB를 밀어올림! 💪

Q:  HIGH → LOW로 변경!
QB: LOW → HIGH로 변경!

시소가 뒤집힘! 🎢
```

**[4단계] 문 닫기 = 새 데이터 고정**
```
워드라인 OFF!
    ↓
  [문1]  [문2] 닫힘!
    |      |
   
셀 내부에 새 데이터 고정:
Q = LOW = '0' ← 성공!
QB = HIGH

시소가 새 위치에서 안정됨
```

### **그림으로 보는 Write**
```
[쓰기 전 - 셀에 '1' 저장]
워드라인: ────── (문 잠김)
셀: Q=HIGH, QB=LOW
    시소1↑  시소2↓

     ↓ 데이터 준비 ('0' 쓰기)

[준비]
BL:  [    ] 0V    ← '0' 준비
BLB: [====] 1.2V

     ↓ 워드라인 ON

[쓰는 중]
워드라인: ━━━━━━ (문 열림!)
BL(0V)  → Q를 끌어내림! ↓↓
BLB(1.2V) → QB를 밀어올림! ↑↑

셀: Q=HIGH→LOW 🔄
    QB=LOW→HIGH 🔄
    시소 뒤집힘!

     ↓ 워드라인 OFF

[쓰기 완료]
워드라인: ────── (문 잠김)
셀: Q=LOW, QB=HIGH
    시소1↓  시소2↑
    
'0' 저장 완료! ✓
```

---

# 핵심 비유 정리

## Read = 훔쳐보기 👀
```
1. 문을 살짝 연다 (워드라인 ON)
2. 안에 뭐가 있나 몰래 본다 (미세한 신호)
3. 돋보기로 자세히 본다 (센스 앰프)
4. 문을 닫는다 (워드라인 OFF)
5. 셀 내용은 그대로! (비파괴)
```

## Write = 강제로 바꾸기 💪
```
1. 바꿀 내용을 준비한다 (비트라인 설정)
2. 문을 연다 (워드라인 ON)
3. 힘으로 밀어붙인다! (강력한 드라이버)
4. 시소가 뒤집힌다! (상태 변경)
5. 문을 닫는다 (새 데이터 고정)
```

---

# DDR2 Read/Write - 쉬운 설명

## DDR2 구조 - 기본 비유

**DRAM 셀 = 작은 물통 하나**
```
[스위치]
    |
[작은 물통] ← 전하 저장
    |
   땅

물이 차있으면 = '1'
물이 비어있으면 = '0'
```

---

# DDR2 Read 과정 🔍

## 준비: 행 열기 (ACTIVE)
```
[1단계] ACTIVE 명령

메모리는 큰 창고:
행(Row) 1000개
열(Column) 1000개

"3번 행을 열어라!"
```

**[2단계] 한 행 전체가 열림**
```
3번 행의 모든 물통(셀)이 열림:

셀 → [물통1][물통2][물통3]...[물통1000]
       ↓      ↓      ↓          ↓
     파이프에 물 흘러나옴 (비트라인)
     
⚠️ 문제: 물통의 물이 파이프로 빠져나감!
→ 물통이 거의 빔 (파괴적 읽기)
```

**[3단계] 센스 앰프가 감지하고 복원**
```
센스 앰프 = 물 감지기 + 펌프

1. 감지: "이 물통에 물이 있었네!"
2. 증폭: 확실하게 HIGH/LOW 만듦
3. 복원: 물을 다시 물통에 채워줌! 💧

물통1: 물 있음 → '1' 확인 → 다시 채움
물통2: 물 없음 → '0' 확인 → 비워둠
```

## Read 명령
```
[4단계] READ 명령 + 컬럼 주소

"3번 행에서 5번 열을 읽어라!"

       열 선택
         ↓
[물통1][물통2][물통3][물통4][물통5]
                              ↑
                           이것 읽기!
```

**[5단계] 프리페치 버퍼**
```
DDR2는 4개씩 한꺼번에 가져옴:

내부에서: [물통5][물통6][물통7][물통8] 가져옴
         =  [  1  ][  0  ][  1  ][  1  ]

버퍼에 임시 저장: [1][0][1][1]
```

**[6단계] 밖으로 전송 (DQS와 함께)**
```
DQS = 박자 맞추는 북소리 🥁

클럭 1번째:
DQS: ↑ (북 치는 순간)
DQ:  [1] 전송!

DQS: ↓ (북 치는 순간)
DQ:  [0] 전송!

클럭 2번째:
DQS: ↑
DQ:  [1] 전송!

DQS: ↓
DQ:  [1] 전송!

2 클럭에 4비트 전송 완료!
```

### **그림으로 보는 DDR2 Read**
```
[1] ACTIVE
창고: [====3번 행====] 열림
       ↓↓↓↓↓↓↓↓↓↓
    비트라인으로 흐름

[2] 센스 앰프 동작
물통들: [1][0][1][1][0]...
         ↓ 감지하고 복원
확정값: [1][0][1][1][0]...

[3] READ (열 5 선택)
선택: [1][0][1][1] ← 4개씩
       ↓↓↓↓
    프리페치 버퍼

[4] 전송
DQS: ↑ ↓ ↑ ↓
DQ:  [1][0][1][1]
     박자 맞춰 전송!

[5] PRECHARGE
창고: [====3번 행====] 닫힘
```

---

# DDR2 Write 과정 ✍️

## Write 명령
```
[1단계] ACTIVE - 행 열기

"3번 행을 열어라!"
센스 앰프가 현재 데이터 읽음
```

**[2단계] WRITE 명령 + 데이터 받기**
```
"3번 행, 5번 열에 쓰기!"

컨트롤러가 데이터 전송:
DQS: ↑ ↓ ↑ ↓ (박자)
DQ:  [1][1][0][1] (새 데이터)

프리페치 버퍼에 저장: [1][1][0][1]
```

**[3단계] 실제로 물통에 쓰기**
```
버퍼의 데이터를 셀로 전송:

열 5번 셀: [1][1][0][1]
            ↓  ↓  ↓  ↓
물통에 쓰기:
물통5: 물 채움 (1)
물통6: 물 채움 (1)
물통7: 물 비움 (0)
물통8: 물 채움 (1)
```

**[4단계] 완료 후 행 닫기 (PRECHARGE)**
```
PRECHARGE 명령

"3번 행을 닫아라!"
워드라인 OFF
센스 앰프 초기화
비트라인 충전

다음 접근 준비 완료!
```

### **그림으로 보는 DDR2 Write**
```
[1] ACTIVE
창고: [====3번 행====] 열림

[2] WRITE + 데이터 입력
DQS: ↑ ↓ ↑ ↓
DQ:  [1][1][0][1]
     ↓↓↓↓
프리페치: [1][1][0][1]

[3] 셀에 쓰기
열 5번:
물통5: [물채움] ← 1
물통6: [물채움] ← 1
물통7: [  비움] ← 0
물통8: [물채움] ← 1

[4] PRECHARGE
창고: [====3번 행====] 닫힘
새 데이터 저장 완료! ✓
```

---

# 핵심 차이점

## SRAM vs DRAM
```
SRAM (시소):
✓ 문만 열면 바로 읽기/쓰기
✓ 데이터 안 사라짐 (비파괴)
✓ 빠름
✗ 비쌈 (시소 구조 복잡)

DRAM (물통):
✓ 싸고 작음
✗ 물이 새서 계속 채워줘야 함 (리프레시)
✗ 읽으면 물이 빠짐 (파괴적)
✗ 느림 (행 열고 → 센싱 → 복원)
```

## 접근 과정
```
SRAM: 간단!
워드라인 ON → 읽기/쓰기 → 끝!

DRAM: 복잡!
ACTIVE(행 열기) 
→ 센싱 & 복원
→ READ/WRITE(열 선택)
→ PRECHARGE(행 닫기)
```

---

# 실생활 비유로 정리

## SRAM = 스위치
```
전등 스위치처럼:
- 켜면 ON (1)
- 끄면 OFF (0)
- 상태 계속 유지
- 바로 확인 가능
```

## DRAM = 양동이
```
물 양동이처럼:
- 물 있으면 (1)
- 물 없으면 (0)
- 구멍 있어서 물 샘 (리프레시 필요)
- 확인하려면 물 떠봐야 함 (파괴적)
```
