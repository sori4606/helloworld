# FPGA

## 목차

- [FPGA 정의](./fpga.md#fpga-field-programmable-gate-array)
- [하드웨어 VS 소프트웨어](./fpga.md#하드웨어-vs-소프트웨어)
- [FPGA의 구성요소](./fpga.md#구성-요소)
- [FPGA의 작동방식](./fpga.md#작동-방식)
- [CPU vs GPU vs FPGA](./fpga.md#cpu-vs-gpu-vs-fpga)
- [FPGA의 장단점](./fpga.md#장점과-단점)
- [주요 사용 분야](./fpga.md#주요-사용-분야)
- [용어 설명](./fpga.md#용어-설명)

## FPGA (Field-Programmable Gate Array)
: 사용자가 하드웨어 회로를 직접 구성할 수 있는 재구성 가능한 논리 장치 <br />

- Field-Programmable: 사용자가 현장에서 직접 프로그래밍할 수 있다는 뜻

- Gate Array: 많은 수의 논리 게이트(AND, OR, NOT 등)가 격자 형태로 배치되어 있음

→ 즉, 하드웨어를 프로그래밍 할 수 있는 칩

### 하드웨어 VS 소프트웨어

하드웨어

- 물리적인 회로
- 한 번 만들면 변경 불가
- 빠름
- 예: CPU, GPU 칩

소프트웨어

- 코드로 작성
- 언제든 수정 가능
- 유연함
- 예: 프로그램, 앱


FPGA = 하드웨어인데, 소프트웨어처럼 변경 가능

- 일반 칩: 공장에서 회로 고정 → 평생 그대로
- FPGA: 사용자가 회로 설계 → 다운로드 → 변경 가능 → 또 변경 가능!

## 구성 요소

| 구성 요소                                 | 설명                                        |
| ------------------------------------- | ----------------------------------------- |
| **Logic Blocks (CLB)**                | 논리 회로의 기본 단위. AND, OR, XOR 등 간단한 논리 연산 수행 |
| **Lookup Tables (LUTs)**              | 입력 조합에 따라 출력을 저장한 테이블. 복잡한 논리도 LUT로 표현 가능 |
| **[Flip-Flops](./fpga.md#2-flip-flop--1비트를-저장하는-가장-기본적인-회로)**                        | 상태 저장 ([레지스터](./fpga.md#1-레지스터--cpu-내부에-있는-가장-빠른-임시-저장-공간) 역할). 순차 논리 회로 구성에 사용          |
| **Switch Matrix / Routing Resources** | 각 논리 블록을 유연하게 연결하는 **배선망**                |
| **I/O Blocks**                        | 외부 장치와 통신하는 입출력 포트                        |
| **Block RAM (BRAM)**                  | FPGA 내부에 있는 작은 메모리 블록                     |
| **DSP Slices**                        | 곱셈, 누산기 등 고속 수학 연산에 최적화된 블록               |

📌 이 모든 것들은 사용자가 작성하는 HDL 코드 (VHDL, Verilog 등)를 통해 재구성 가능하다


## 작동 방식

1. 사용자는 Verilog/VHDL 같은 하드웨어 기술 언어(HDL)로 원하는 회로 동작을 설계

2. FPGA 툴(예: Xilinx Vivado, Intel Quartus)을 통해 컴파일 및 합성 (코드 -> 실제 논리 게이트로 변환하는 과정)

```
sum = a + b
  ↓
XOR, AND, OR 게이트들의 조합으로 변환
```

3. 논리 게이트를 FPGA의 어느 블록에 배치하고, 블록들을 어떻게 연결할지 결정

4. 비트스트림 생성 (FPGA 설정 정보를 파일로 저장) <br />
(→ .bit 파일 또는 .sof 파일)

5. FPGA에 비트스트림을 로딩하면 그 즉시 해당 하드웨어 회로로 동작

## CPU vs GPU vs FPGA

### 1. CPU

**특징**

- 순차적 처리
- 복잡한 로직

**구조**

- 고정된 범용 회로

```
[입력] → [CPU 회로(고정)] → [출력]
         └─ 소프트웨어로 동작 제어
```

### 2. GPU

**특징**

- 병렬 처리
- 단순 반복

**구조**

- 고정된 병렬 회로

```
[입력들] → [GPU 회로(고정)] → [출력들]
           └─ 수천 개 코어 동시 작동
```

### 3. FPGA

**특징**

- 맞춤형 회로
- 특화된 작업

**구조**

- 사용자가 회로 직접 설계

```
[입력] → [FPGA 회로(사용자 정의)] → [출력]
         └─ 회로 자체를 변경 가능
```

| 항목     | CPU               | GPU            | FPGA                  |
| ------ | ----------------- | -------------- | --------------------- |
| 설계 목적  | 범용 컴퓨팅            | 대규모 병렬 연산      | 맞춤형 하드웨어 구현           |
| 처리 방식  | 순차적               | 병렬적            | **완전 사용자 정의 병렬**      |
| 유연성    | 높음                | 중간             | 매우 높음 (회로 재설계 가능)     |
| 속도     | 중간                | 빠름 (병렬)        | 매우 빠름 (맞춤 설계시)        |
| 소비 전력  | 보통                | 높음             | **낮음 (전용 회로라 효율적)**   |
| 프로그래밍  | 소프트웨어 (C, Python) | CUDA, OpenCL 등 | HDL (Verilog, VHDL 등) |
| 개발 난이도 | 낮음                | 중간             | **높음**                |
| 변경 가능성 | 불가능 (하드웨어 고정)     | 불가능            | **가능 (재구성 가능)**       |

## 장점과 단점

### 장점

| 항목                         | 설명                                        |
| -------------------------- | ----------------------------------------- |
| **재구성 가능**                 | 필요에 따라 하드웨어 구조를 계속 바꿀 수 있음                |
| **병렬성 극대화**                | 수천 개의 연산 유닛을 직접 구성 가능 (완전한 병렬 구조 설계 가능)   |
| **고성능**                    | 특정 작업에 최적화된 회로 설계 → **CPU/GPU보다 빠를 수 있음** |
| **낮은 지연 시간 (Low Latency)** | 하드웨어에서 직접 실행되므로 처리 속도가 매우 빠름              |
| **낮은 전력 소비**               | 불필요한 회로가 없기 때문에 매우 효율적임                   |

### 단점

| 항목                | 설명                               |
| ----------------- | -------------------------------- |
| **개발 난이도**        | HDL 언어 학습 필요. 디버깅, 타이밍 설계 등 복잡   |
| **설계 시간 길다**      | 회로 설계, 합성, 배치, 타이밍 분석 등 시간이 많이 듦 |
| **처리 속도 제한 있음**   | 클럭 속도는 CPU보다 낮음 (200~500 MHz 수준) |
| **소프트웨어와 호환 어려움** | 일반적인 프로그램을 직접 실행할 수 없음           |
| **비용**            | 고급 FPGA는 가격이 비쌈 (산업용 기준)         |

## 주요 사용 분야

| 분야           | 설명                             |
| ------------ | ------------------------------ |
| **통신장비**     | 5G/6G 베이스밴드 처리, 고속 신호 처리 등     |
| **영상처리**     | 실시간 4K/8K 비디오 인코딩, 디코딩         |
| **금융**       | 초고속 알고리즘 트레이딩 (초단타 매매)         |
| **인공지능**     | CNN 등 딥러닝 모델을 FPGA로 구현 (효율성 ↑) |
| **자동차**      | ADAS, 센서 융합, 자율주행 제어           |
| **항공/우주/국방** | 높은 안정성과 맞춤형 설계 필요 분야           |
| **의료기기**     | MRI, 초음파 등 실시간 신호 처리 장치        |


## 용어 설명

### 1. 레지스터 : CPU 내부에 있는 가장 빠른 임시 저장 공간 (= 여러 flip-flop의 모음)

특징:
- 가장 빠름 (1 클럭 사이클)
- CPU 내부에 위치
- 매우 작음 (수십 바이트)
- 모든 연산의 중심

구성:
- Flip-Flop들의 집합
- 32비트 레지스터 = 32개 Flip-Flop
- 64비트 레지스터 = 64개 Flip-Flop

역할:
- 계산 중간 결과 저장
- 명령어 실행의 기반
- 메모리와 ALU 사이의 다리

```
8비트 레지스터 = 8개의 Flip-Flop

[FF] [FF] [FF] [FF] [FF] [FF] [FF] [FF]
 ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓
 비트7 비트6 비트5 비트4 비트3 비트2 비트1 비트0

예: 숫자 42 (이진수: 00101010) 저장
[0]  [0]  [1]  [0]  [1]  [0]  [1]  [0]
```


### 2. Flip-Flop : 1비트를 저장하는 가장 기본적인 회로

```
┌──────────────┐
│  Flip-Flop   │
├──────────────┤
│ 입력: D      │ ← 1비트 입력
│ 클럭: CLK    │ ← 타이밍 신호
│ 출력: Q      │ ← 1비트 출력 (저장된 값)
└──────────────┘

동작:
클럭 신호가 올 때마다
→ D의 값을 Q에 저장
→ Q는 다음 클럭까지 값 유지
```

```
1비트 저장: Flip-Flop
  ↓
여러 비트: 레지스터 (Flip-Flop 여러 개)
  ↓
대량 저장: 메모리 (레지스터 수백만 개)
```
