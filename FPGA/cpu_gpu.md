# CPU VS GPU

## 목차

- [CPU란 ?](./cpu_gpu.md#cpu)
- [GPU란 ?](./cpu_gpu.md#gpu)
- [CPU vs GPU 구조적 차이](./cpu_gpu.md#1-구조적-차이)
- [CPU vs GPU 처리 방식 차이](./cpu_gpu.md#2-처리-방식-차이-직렬-vs-병렬)
- [용어 설명](./cpu_gpu.md#용어-설명)

## CPU
: 중앙 처리 장치. 컴퓨터의 "뇌"로, 모든 계산과 명령을 처리한다.

## GPU
: 그래픽 처리 장치. 원래는 화면에 그림을 그리기 위한 장치였지만, 지금은 훨씬 더 많은 일을 함.

## CPU vs GPU

### 1. 구조적 차이

1. CPU 구조

    - 보통 4~16개의 고성능 [코어](./cpu_gpu.md#1-코어-core)로 구성

    - 각 코어는 복잡한 명령어 처리 가능 ([branch](./cpu_gpu.md#2-branch--프로그램의-실행-흐름을-바꾸는-것),[interrupt](./cpu_gpu.md#3-interrupt--급한-일이-생겨서-현재-작업을-멈추고-다른-일을-처리하는-것) 등)

    - 큰 캐시 메모리를 사용해 빠른 데이터 접근

2. GPU 구조

    - 수백~수천 개의 작은 연산 유닛 ([ALU](./cpu_gpu.md#4-alu-arithmetic-logic-unit---연산-유닛)) 로 구성

    - 동일한 명령을 다수의 데이터에 동시에 적용하는 구조 ([SIMD](./cpu_gpu.md#5-simd-single-instruction-multiple-data))

    - 복잡한 제어보다는 대량의 계산 처리에 특화


| 항목    | CPU           | GPU             |
| ----- | ------------- | --------------- |
| 코어 수  | 적음 (4~16)     | 많음 (수백~수천)      |
| 코어 성능 | 고성능           | 단순하지만 대량        |
| 제어 능력 | 강함 (분기, 로직 등) | 약함 (일괄 작업에 최적화) |

### 2. 처리 방식 차이 (직렬 vs 병렬)

1. CPU

    - 직렬 처리
    - 한 번에 한 명령어를 처리
    - 논리적 판단, 조건 분기, 순차 처리에 적합 ([운영체제](./cpu_gpu.md#6-운영체제-operating-system-os), 게임 로직 등)

2. GPU

    - 병렬 처리
    - 동일 명령어를 수천 개 데이터에 적용
    - 대량의 데이터를 동시에 계산 (이미지 처리, 딥러닝, 벡터 연산 등)


| 항목    | CPU              | GPU                 |
| ----- | ---------------- | ------------------- |
| 목적    | 범용 처리            | 병렬 연산 최적화           |
| 구조    | 소수의 고성능 코어       | 다수의 저전력 코어          |
| 처리 방식 | 직렬               | 병렬                  |
| 장점    | 유연성, 제어력, 복잡한 연산 | 대량 데이터 연산 처리        |
| 단점    | 병렬 처리 한계         | 제어 복잡성, 메모리 제한      |
| 사용 예  | OS, 앱, 게임 로직     | 그래픽, AI, 과학 계산, 렌더링 |

## 용어 설명

### 1. 코어 (Core)
: 독립적으로 계산할 수 있는 처리 장치

CPU 코어

- 크고 강력
- 복잡한 일 가능
- 각자 다른 일 할 수 있음

ex.

```
4코어 CPU:
코어1: 웹브라우저 실행
코어2: 음악 재생
코어3: 파일 다운로드
코어4: 백그라운드 작업
```

GPU 코어

- 작고 단순
- 간단한 일만 가능
- 모두 같은 일 해야함

ex.

```
4000코어 GPU:
모든 코어: 같은 명령(색상 계산)을 다른 픽셀에 적용
코어1: 픽셀1 계산
코어2: 픽셀2 계산
코어3: 픽셀3 계산
...
코어4000: 픽셀4000 계산
```

### 2. branch : 프로그램의 실행 흐름을 바꾸는 것

프로그래밍 예시

```python
if (나이 >= 20):        # ← 여기서 분기 발생!
    print("성인입니다")   # 경로 A
else:
    print("미성년자입니다") # 경로 B
```

```
1. CPU는 빠른 처리를 위해 다음 명령어를 미리 준비함
2. 분기문(if)에서 어느 쪽으로 갈지 예측
3. 예측한 쪽의 명령어를 미리 가져와서 준비
4. 예측이 맞으면: 엄청 빠름! (3~5배 빠름)
5. 예측이 틀리면: 준비한 것 전부 버리고 처음부터
→ 시간 낭비 (하지만 보통 예측이 90% 이상 맞음)
```

왜 복잡한가?:

- CPU는 미리 예측해서 명령어를 준비함 (Branch Prediction)
- 예측이 틀리면 준비한 걸 버리고 다시 시작 (비효율)
- GPU는 이런 복잡한 예측 기능이 약함

### 3. Interrupt : 급한 일이 생겨서 현재 작업을 멈추고 다른 일을 처리하는 것

컴퓨터 예시


```
CPU: 계산 중...
     ↓
키보드: "키를 눌렀어요!" (인터럽트)
     ↓
CPU: 계산 멈춤 → 키 입력 처리 → 다시 계산 재개
```

왜 CPU가 필요한가?:

- 언제 어디서 인터럽트가 올지 모름
- 유연하게 대응해야 함
- GPU는 이런 즉각 대응이 약함

### 4. ALU (Arithmetic Logic Unit) - 연산 유닛

산술 연산, 논리 연산, 비교 연산 등을 수행

```
┌────────────────────┐
│      CPU 코어       │
├────────────────────┤
│  제어 유닛          │ ← 명령어 해석, 지시
│       ↓            │
│  [ALU]             │ ← 실제 계산 담당!
│   - 덧셈           │
│   - 뺄셈           │
│   - 곱셈           │
│   - 나눗셈         │
│   - AND, OR, NOT   │
└────────────────────┘
```

CPU : 코어 하나에 ALU 1~2개

    - 복잡한 계산 가능
    - 큰 숫자 처리 가능
    - 다양한 연산 지원

GPU : 코어 하나에 ALU 1개 (but, 코어가 수천개)

    - 단순한 계산만 가능
    - 작은 숫자 주로 처리
    - 같은 연산만 반복


### 5. SIMD (Single Instruction Multiple Data)
: 하나의 명령어로 여러 데이터를 동시에 처리

일반 방식 :

```python
# 4개 숫자에 각각 2 더하기
a = 1 + 2  # 3
b = 3 + 2  # 5
c = 5 + 2  # 7
d = 7 + 2  # 9

→ 4번의 덧셈 명령
```

SIMD 방식 : 

```
# 4개 숫자에 동시에 2 더하기
[1, 3, 5, 7] + 2 = [3, 5, 7, 9]

→ 1번의 명령으로 4개 동시 처리!
```

### 6. 운영체제 (Operating System, OS)
: 컴퓨터 하드웨어와 사용자 사이의 중개자

역할

1. 자원 관리

```
CPU 시간 배분:
크롬: 30%
게임: 50%
음악: 10%
백그라운드: 10%
```

2. 메모리 관리
```
RAM 16GB 배분:
- 윈도우: 2GB
- 크롬: 4GB
- 게임: 8GB
- 기타: 2GB
```

3. 파일 관리
```
- 파일 저장/읽기
- 폴더 구조 관리
- 권한 관리 (읽기/쓰기)
```

4. 입출력 관리
```
키보드 입력 → OS → 프로그램
마우스 클릭 → OS → 프로그램
화면 출력 ← OS ← 프로그램
```

대표적인 운영체제
```
- Windows 10/11 (개인용 PC)
- macOS (애플 컴퓨터)
- Linux (개발자, 서버)
- Android (스마트폰)
- iOS (아이폰)
```