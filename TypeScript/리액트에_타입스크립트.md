## 리액트에 타입스크립트 적용하기

### HTML 타입

1. HTMLElement 타입
   : `HTML<태그이름>Element` 라는 이름으로 DOM 노드에 대한 타입을 사용할 수 있음. <br />

   ex.

```tsx
const usernameInput = document.getElementById("username") as HTMLInputElement;
const submitButton = document.getElementById("submit") as HTMLButtonElement;
```

| HTML 태그  | 타입스크립트 타입 예시 |
| ---------- | ---------------------- |
| `<input>`  | `HTMLInputElement`     |
| `<button>` | `HTMLButtonElement`    |
| `<form>`   | `HTMLFormElement`      |
| `<select>` | `HTMLSelectElement`    |
| `<div>`    | `HTMLDivElement`       |

2. DOM 이벤트 타입
   : 기본적으로 Event라는 타입을 쓸 수 있고, 구체적으로는 -Event로 끝나는 타입을 활용하면 됨. (InputEvent, MouseEvent 등) 브라우저가 제공하는 기본 이벤트 타입.

```tsx
document.addEventListener("click", (e: MouseEvent) => {
  console.log(e.clientX);
});
```

### React 타입

#### 1. 컴포넌트 Props 타입 지정하기. `children`의 경우 `ReactNode`라는 타입 사용.

ex.

```jsx
interface Props {
  className?: string;
  id?: string;
  children?: ReactNode;
  onClick: (e: MouseEvent<HTMLButtonElement>) => void;
}

const Button = ({ className = "", id, children, onClick }: Props) => {
  const classNames = `${styles.button} ${className}`;
  return (
    <button className={classNames} id={id} onClick={onClick}>
      {children}
    </button>
  );
};

export default Button;
```

#### HTML 기본 Props를 타입으로 정의하고 싶다면 ? `태그이름HTMLAttributes<노드타입>`

ex.

```jsx
interface Props extends InputHTMLAttributes<HTMLInputElement> {}

export default function Input({ className = "", ...rest }: Props) {
  const classNames = `${styles.input} ${className}`;
  return <input className={classNames} {...rest} />;
}
```

#### 2. Hook에서의 타입 적용

### ✅ useState – 초깃값 기반 타입 추론

`useState`는 초깃값을 명확하게 지정해주면 타입스크립트가 알아서 타입을 추론해준다.

```tsx
const [count, setCount] = useState(0); // number
const [username, setUsername] = useState("홍길동"); // string
const [names, setNames] = useState<string[]>([]); // string[]
```

하지만 초깃값이 null이거나 조건부 초기화일 땐, 제네릭으로 타입을 직접 명시해야 안전하다.

```tsx
const [selectedId, setSelectedId] = useState<number | null>(null);
```

### ✅ useRef – DOM 요소에 타입 지정

`useRef`는 **DOM 요소를 참조할 때**, 제네릭으로 해당 요소의 타입을 명시하고
초깃값으로 `null`을 넣으면 안전하게 사용할 수 있다.

```tsx
const formRef = useRef<HTMLFormElement>(null);
const inputRef = useRef<HTMLInputElement>(null);
```

⚠️ .current에 접근할 때는 항상 null 체크를 잊지 말자!

```tsx
useEffect(() => {
  if (formRef.current) {
    formRef.current.focus(); // 정상 작동
  }
}, []);
```

#### 3. 이벤트 핸들러

HTML과 마찬가지로 -Event 형식. 어떤 이벤트인지 타입을 구체적으로 지정할 필요가 없는 경우라면 SyntheticEvent라는 타입을 사용. <br />
**주의할점**은 HTML자바스크립트에서 사용하는 MouseEvent가 아니라, react패키지에서 불러와서 사용하는 MouseEvent임. (이름이 같은 게 있음) 주의해서 사용해라.

```tsx
import { ChangeEvent, MouseEvent, useEffect, useRef, useState } from "react";

// ...

function handleChange(e: ChangeEvent<HTMLInputElement>) {
  const { name, value } = e.target;
  const nextValues = {
    ...values,
    [name]: value,
  };
  setValues(nextValues);
}

function handleClick(e: MouseEvent<HTMLButtonElement>) {
  // function handleClick(e: SyntheticEvent)처럼 쓸 수도 있음
  e.preventDefault();

  const message = `${values.username}님 환영합니다`;
  alert(message);
}
```

### `DOM 이벤트` VS `React 이벤트`

리액트에서는 브라우저의 기본 DOM 이벤트 대신, `SyntheticEvent`라는 **React 전용 이벤트 시스템**을 사용함.

---

#### 1. React는 `SyntheticEvent`를 사용한다

- React는 브라우저의 `Event` 객체를 감싸서 자체적으로 추상화한 `SyntheticEvent`를 제공함.
- 이를 통해 브라우저 간의 이벤트 처리 차이를 줄이고, **일관된 방식**으로 이벤트를 처리할 수 있음.
- 예를 들어 `e.preventDefault()`, `e.stopPropagation()` 같은 메서드는 DOM 이벤트와 동일하게 사용 가능.

---

#### 2. React 이벤트는 타입 추론이 더 정밀하다

- React 이벤트 타입 (`React.ChangeEvent`, `React.MouseEvent` 등)을 사용하면,
  `e.target`, `e.currentTarget` 등에서 **정확한 타입 추론이 가능**함.

ex.

```tsx
const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  const value = e.target.value; // ✅ string으로 정확히 추론됨
};
```

잘못된 ex. DOM 이벤트 타입을 React에 쓰는 경우

```tsx
const handleChange = (e: Event) => {
  console.log(e.target.value); // ❌ 오류! 'value'는 'EventTarget'에 없음
};
```

- DOM의 EventTarget은 타입스크립트 기준으로 value나 checked 등의 속성을 가지고 있지 않기 때문에, 타입 단언 (type assertion)을 따로 해줘야 함.

```tsx
const input = e.target as HTMLInputElement;
console.log(input.value); // 이렇게 해야 동작
```

→ 하지만 이런 방식은 추론도 안 되고, 매번 단언이 필요해서 귀찮고 불안정함.

#### `결론`

- 리액트 컴포넌트 내에서는 반드시 React.MouseEvent, React.ChangeEvent 등 React 전용 이벤트 타입을 사용해야 한다.

- DOM의 이벤트 타입 (Event, MouseEvent 등)은 addEventListener()로 직접 브라우저 API를 쓸 때만 사용한다.

```ts
document.addEventListener("scroll", (e: Event) => { ... }); // 이럴 땐 DOM 타입 사용
```
