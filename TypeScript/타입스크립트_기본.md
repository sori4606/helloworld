## 타입스크립트 기본

### 배열과 튜플

#### `배열`

특징 <br />

- 같은 타입의 요소만 반복적으로 저장
- 길이 제한 없음
- 2가지 문법 지원:
  1. 타입 [ ]
  2. Array<타입>

ex.

```tsx
const cart: string[] = [];
cart.push("c001");
cart.push("c002");

const numbers: number[] = [1, 2, 3];
const strings: Array<string> = ["a", "b", "c"];

// 2차원 배열
const carts: string[][] = [["c001", "c002"], ["c003"]];
```

#### `튜플`

특징 <br />

- 각 인덱스의 타입과 순서가 고정
- 요소 개수가 정해져 있음 (길이가 변하면 타입 오류)
- 구조분해 할당 시 자동으로 타입 추론 가능

```jsx
let mySize: [number, number, string] = [175, 30, "L"];

let user: [string, number] = ["Hong", 30];

const [name, age] = user; // name: string, age: number
```

### 객체 타입

: `{}` 안에 프로퍼티 이름과 타입을 지정. 각 프로퍼티는 세미콜론으로 구분하고, 선택적 프로퍼티는 `?`를 붙임. 읽기 전용 속성은 `readonly`를 붙임.

ex.

```tsx
let product: {
  readonly id: string; // 수정 불가
  name: string;
  price: number;
  membersOnly?: boolean; // 필수가 아닌 프로퍼티
  sizes: string[];
} = {
  id: "c001",
  name: "코드잇 블랙 후디",
  price: 129000,
  sizes: ["M", "L", "XL"],
};

if (product.membersOnly) {
  console.log("회원 전용 상품");
} else {
  console.log("일반 상품");
}

product.name = "신상 후디"; // ✅ 가능
// product.id = "c002"; ❌ readonly라서 불가
```

#### 인덱스 시그니처

: 객체의 키가 동적으로 정해질 때, `[키이름: 키타입]: 값타입` 문법을 사용.

```tsx
type Stock = {
  [size: string]: number;
};

const stock: Stock = {
  S: 5,
  M: 3,
  L: 2,
};
```

#### 타입 별칭(Type Alias) & 중첩 객체

: `type` 키워드로 객체 타입을 재사용 가능하게 정의하며, 다른 객체 타입을 중첩할 수 있음.

```tsx
type Size = "S" | "M" | "L" | "XL";
type Category = { id: string; name: string };

type Product = {
  id: string;
  name: string;
  price: number;
  sizes: Size[];
  category: Category;
};

const hoodie: Product = {
  id: "c001",
  name: "후디",
  price: 129000,
  sizes: ["M", "L"],
  category: { id: "cat01", name: "상의" },
};
```

### 함수 타입

#### 1. 리턴 타입을 지정하는 경우

매개변수 뒤에 `:` 반환타입을 붙여 함수 반환 타입을 명시.

```jsx
function addToCart(id: string, quanity: number): boolean {
    if (어떤 조건) {
     return false;
  }

  return true;
}
```

#### 2. 리턴 값으로부터 추론하게 하는 경우

: 반환 타입을 생략하면 코드에서 자동 추론.

```tsx
function addToCart(id: string, quanity: number) {
    if (어떤 조건) {
     return false;
  }

  return true;
}
```

#### 3. 화살표 함수 타입

: 함수 타입을 변수처럼 선언하고 할당 가능

```tsx
type AddToCart = (id: string, quantity: number) => boolean;

const addToCart: AddToCart = (id, quantity) => quantity > 0;
```

#### 4. Rest 파라미터

: Rest 파라미터는 배열 타입으로 지정

```tsx
const addMultiple = (...ids: string[]): void => {
  console.log(ids.join(", "));
};
```

#### 5. 기본값과 선택적 매개변수

: 매개변수에 기본값을 지정하거나, 선택적 매개변수는 `?`를 사용<br />
기본값 매개변수는 인자값이 undefined로 들어오면 지정한 기본값을 사용한다.

```tsx
// 1) 기본값: undefined일 때만 트리거
function priceWithTax(price: number, rate: number = 0.1) {
  return price * (1 + rate);
}
priceWithTax(100); // 110
priceWithTax(100, undefined); // 110
priceWithTax(100, 0.2); // 120

// 2) 선택적 매개변수: 타입이 number | undefined
function greet(name: string, age?: number) {
  return age ? `안녕, ${name}(${age})` : `안녕, ${name}`;
}
greet("상호"); // OK
greet("상호", 34); // OK

// 3) 기본값 vs 선택적의 타입 차이
function f1(x: number = 5) {
  /* x: number */
}
function f2(x?: number) {
  /* x: number | undefined */
}

// 4) 구조분해 + 기본값(빈 객체 대비)
type Opt = { page?: number; pageSize?: number };
function listItems({ page = 1, pageSize = 20 }: Opt = {}) {
  return { page, pageSize };
}
listItems(); // {1, 20}
listItems({ page: 2 }); // {2, 20}
listItems({ pageSize: 50 }); // {1, 50}
listItems({ page: 3, pageSize: 5 }); // {3, 5}

// 5) 이전 인자를 이용한 기본값
function range(to: number, from: number = 0) {
  return Array.from(
    { length: to - from }, // N개의 공간 만들고
    (_, i) => i + from // i를 시작값부터 순차적으로 증가
  );
}
range(5); // [0..4] -> [0, 1, 2, 3, 4]
range(5, 2); // [2..4] -> [2, 3, 4]
```

- `listItems`에서 `Opt = {}` 구조 ? <br />

  : 타입을 지정하고, 기본값을 설정함. <br />
  만약, `: Opt` 로 타입지정만 하면, `listItems()` 처럼 아예 인자를 생략하는 호출시 `undefined`로 들어와서 런타임 오류 발생.

- `Array.from()` ?

  : 유사 배열 + 맵 기능이 결합된 배열 생성 도구

`Array.from()`은 두 가지 인자를 받음 :

```ts
Array.from(arrayLike, mapFn);
```

-> 여기서 `arrayLike`에 `{length: N}`을 넣으면, 길이가 N인 배열을 만들어줌

-> `function range` 에서, (_ , i)에서 `_`의 의미 ? <br />

```ts
(_, i) => i + from;
```

-> Array.from()의 두 번째 인자 mapFn은 (value, index)를 받음

-> 여기선 첫 번째 값(value)은 항상 undefined이므로 \_로 무시

-> i는 현재 인덱스(0부터 시작)

-> i + from은 시작값부터 순차 증가시키는 숫자 생성

-> 첫 번째 인자는 무시하고, 인덱스만 쓰겠다는 의미 (`_`는 관용적으로 "안 쓰는 변수")

#### 6. 함수 오버로드

: 매개변수 타입에 따라 반환 타입이 달라지는 함수를 정의할 때 사용

```tsx
type Size = "S" | "M" | "L" | "XL";

type Product = {
  id: number;
  sku: string;
  name: string;
  price: number;
  sizes: Size[];
};

function getItem(id: number): Product;
function getItem(name: string): Product[];
function getItem(value: number | string): Product | Product[] {
  if (typeof value === "number") {
    return { id: "c001", name: "후디", price: 129000, sizes: ["M"] };
  } else {
    return [
      { id: "c001", name: "후디", price: 129000, sizes: ["M"] },
      { id: "c002", name: "티셔츠", price: 59000, sizes: ["L"] },
    ];
  }
}
```

- 허용될 타입 갯수가 많아질수록 코드가 길어지고, 가독성 안좋아짐 -> 제네릭으로 해결

7. 함수 타입 유틸리티

   : 기존 함수의 매개변수와 반환 타입을 재활용

```tsx
function addToCart(id: string, quantity: number): boolean {
  return quantity > 0;
}

type Params = Parameters<typeof addToCart>; // [string, number]
type Result = ReturnType<typeof addToCart>; // boolean

function callWithParams(...args: Params) {
  return addToCart(...args);
}

callWithParams("abc", 3); // 타입 안전하게 호출 가능

const result: Result = addToCart("c001", 2); // result는 boolean 타입
```

설명

- `Parameters<T>`는 함수 타입 T의 매개변수들을 튜플로 추출함
- `typeof addToCart`는 addToCart 함수의 타입을 가져옴
- `ReturnType<T>`는 함수 T의 반환 타입을 추출

### Enum

- enum은 자동으로 숫자를 부여하거나, 명시적으로 문자열을 부여할 수 있음
- 중괄호 안에서 각 항목을 쉼표로 구분해서 적어주고, 기본값은 0부터 시작.
- const enum: 더 가볍게 컴파일됨 (값만 남고 열거형 자체는 제거됨)

```tsx
enum Size {
  S,
  M,
  L = 5,
  XL, // 6,
}

console.log(Size[0]); // S
console.log(Size.S); // 0
console.log(Size.L); // 5

//OR

enum Size {
  S = "S",
  M = "M",
  L = "L",
  XL = "XL",
}
// 이런식으로 값을 고정해놓고 쓸 수 있다

// const enum: 런타임에 enum 코드 자체가 제거됨 (성능 최적화)
const enum Axis {
  X,
  Y,
}
const pos = Axis.X; // 0만 남음
```

### interface

- `interface`를 쓴 다음, 객체 타입처럼 만들면 됨
- `interface`는 확장, 병합, 클래스 타입 정의에도 쓰임
- 동일 이름 interface 여러 번 선언 가능 (Declaration Merging)

```tsx
// interface
interface Product {
  id: string;
  name: string;
  price: number;
  membersOnly?: boolean;
}

// 다중 interface 병합
interface User {
  id: string;
}
interface User {
  name: string;
}
const user: User = { id: "u01", name: "민수" };

// 클래스 타입 정의
interface Drivable {
  drive(): void;
}
class Car implements Drivable {
  drive() {
    console.log("주행 중...");
  }
}
```

- 여기서 `Car`는 `Drivable` 인터페이스를 **구현(implements)** 한 거고, `Drivable`에 정의된 `drive()` 메서드를 반드시 정의해야 함.

#### `interface 상속`

: `interface` 이름뒤에 `extends`를 적은 다음 부모 `interface` 이름 적기

```tsx
interface ClothingProduct extends Product {
  sizes: Size[];
}

const product1: ClothingProduct = {
  id: "c001",
  name: "코드잇 블랙 후드 집업",
  price: 129000,
  membersOnly: true,
  sizes: [Size.M, Size.L],
};
```

### Type

쓰이는 상황 <br />

- 유연한 타입 조합
- 조건부 타입
- 유니언/인터섹션

ex1) 유니언 타입으로 버튼 타입 정의

```tsx
type ButtonType = "submit" | "reset" | "button";
```

ex2) 복잡한 조합

```tsx
type Base = { id: number };
type Admin = Base & { role: "admin" };
type Guest = Base & { role: "guest" };
type User = Admin | Guest;
```

ex3) 조건부 타입

```tsx
type IsString<T> = T extends string ? "Yes" : "No";

type A = IsString<string>; // "Yes"
type B = IsString<number>; // "No"
```

언제 `type` VS `interface` ?

| 비교 항목         | `interface`                 | `type`                                         |
| ----------------- | --------------------------- | ---------------------------------------------- |
| 확장(상속)        | `extends` 키워드로 가능     | `&` 연산자로 인터섹션                          |
| 병합(Merging)     | O (동일 이름으로 병합 가능) | ❌ (재선언 불가)                               |
| 객체 외 타입 표현 | ❌ (객체 전용)              | ⭕ (`string`, `number`, `유니언`, `조건부` 등) |
| 사용 대상         | 클래스, 객체 구조           | 유연한 조합, 고급 타입                         |
| 권장 상황         | 외부에 공개할 API 타입 정의 | 내부 조합, 매핑, 복잡한 구조                   |

### 타입을 조작하는 4가지 핵심 문법

#### 1. keyof

: 객체 타입에서 프로퍼티 이름들을 모아서 Union한(합집합) 타입으로 만들고 싶을 때 사용 <br />
→ 타입 시스템에서 “이 타입이 가진 속성 이름들”만 뽑을 수 있음

ex) 타입의 keyof - 객체의 키를 타입으로 추출

```tsx
type User = {
  id: number;
  name: string;
};

type UserKeys = keyof User; // "id" | "name"

function getValue(obj: User, key: UserKeys) {
  return obj[key]; // key가 "id" | "name" 중 하나이므로 안전
}
```

#### 2. in

타입 레벨에서 반복문(for-in)처럼 동작 <br />
→ Mapped Type을 만들 때 사용 (`Mapped Type` ? : 기존 객체 타입의 key들을 순회하면서 새로운 타입을 만들어내는 문법)<br />
→ 주로 `keyof`랑 함께 씀 <br />

ex.

```tsx
type User = {
  id: number;
  name: string;
};

type Flags = {
  [K in keyof User]: boolean; // 일반적으로 K로 씀(Key라서)
};
// 결과: { id: boolean; name: boolean }
```

코드 해석

- `keyof User` → `"id" | "name"`
- `K in keyof User` → K는 `"id"` 또는 `"name"` 를 하나씩 순회한다
- `[K in keyof User]: boolean` → 각 key에 대해 boolean 타입 부여

#### 3. extends

: 조건부 타입 만들기 <br />
(여기서 쓰이는 extends는 interface에서 쓰이는 extends랑 다르다.)

1. 조건부 타입 : 삼항 조건문처럼 동작

```tsx
type IsString<T> = T extends string ? "Yes" : "No"; // T가 string에 할당가능하다면 Yes, 아니면 No.

type A = IsString<string>; // "Yes"
type B = IsString<number>; // "No"
```

2. 제네릭 제약 : 특정 속성을 반드시 포함하는 타입만 받도록 제한

```tsx
function printName<T extends { name: string }>(obj: T) {
  console.log(obj.name);
}

printName({ name: "민수", age: 30 }); // OK
printName({ name: "지은" }); // ✅ OK
printName({ age: 30 }); // ❌ 에러: name이 없음
```

#### 4. infer

: 조건부 타입 안에서 타입을 꺼내서 변수처럼 추론할 수 있게 해줌 <br />
→ 보통 함수 반환 타입 추론, 배열 요소 타입 추론 등에 많이 씀

```tsx
type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

type Fn = () => number;

type Result = MyReturnType<Fn>; // number

// 다른 예제
type ElementType<T> = T extends (infer U)[] ? U : never;

type A = ElementType<string[]>; // string
type B = ElementType<number[]>; // number
type C = ElementType<boolean>; // never
```

코드설명 <br />

1. `T`가 `(...args: any[]) => R` 이런 함수 모양이면
2. 그 함수의 리턴값 타입을 `R`로 추론(infer) 하겠다.
3. 추론에 성공하면 `R`을 반환하고
4. 실패하면(즉, 함수가 아니면) `never`를 반환.
5. 밑에 예제도 똑같이, `T`가 `U[]` 형식이면 `U`를 추론하고, 아니면 `never`

### Union 타입 , Intersection 타입

: `Union`은 `|` , `Intersection`은 `&`

ex.

```tsx
type A = { name: string };
type B = { age: number };

type Union = A | B; (합집합)
type Intersection = A & B; (교집합)

Union 타입 : A 또는 B면 된다.
const person1: Union = { name: '민수' };
const person2: Union = { age: 30 };
const person3: Union = { name: '민수', age: 30 }; // 이것도 OK

Intersection 타입 : A 그리고 B 모두 만족해야한다.
const person: Intersection = { name: '민수', age: 30 }; // OK
const fail1: Intersection = { name: '민수' }; // ❌ age 없음
const fail2: Intersection = { age: 30 }; // ❌ name 없음

```

### 제네릭

: 값이 아니라 타입을 인자로 받는 함수나 타입, 클래스

- 함수나 타입을 만들 때, 구체적인 타입을 고정하지 않고
  나중에 타입을 "전달"받아서 사용하는 방식

- 마치 함수가 값을 파라미터로 받듯, 제네릭은 타입을 파라미터로 받는다

#### `기본 구조`

```ts
function func<T>(value: T): T {
  return value;
}
```

- `<T>` : 타입 매개변수 선언

- `value: T`: 함수의 매개변수에 전달된 타입

- `: T` : 반환값 타입도 동일하게 설정

사용 시점에 T에 어떤 타입이 들어오는지에 따라 함수가 자동으로 타입을 추론하거나, 직접 명시할 수 있음 <br />

#### ex1) 타입 추론하게 하기

```tsx
function identity<T>(value: T): T {
  return value;
}

const a = identity(123); // T는 number로 추론됨
const b = identity("hello"); // T는 string으로 추론됨
```

#### ex2) 직접 타입 지정

```ts
identity<string>("민수");
identity<number>(42);
```

#### ex3) 배열 처리 (많이 씀)

```ts
function first<T>(items: T[]): T {
  return items[0];
}

const num = first([10, 20, 30]); // T = number
const str = first(["a", "b"]); // T = string
```

#### ex4) 여러개의 제네릭

```ts
function pair<K, V>(key: K, value: V): [K, V] {
  return [key, value];
}

const result = pair("id", 123); // [string, number]로 자동추론
```

- 여기서 `pair`는 두 개의 타입을 받아서, [key, value] 튜플 형태로 리턴하는 제네릭 함수

#### ex5) 제네릭 타입 정의

```ts
type Box<T> = {
  value: T;
};

const stringBox: Box<string> = { value: "hello" };
const numberBox: Box<number> = { value: 123 };
```

#### ex6) 제네릭 클래스

```ts
class Queue<T> {
  private items: T[] = [];

  enqueue(item: T) {
    this.items.push(item);
  }

  dequeue(): T | undefined {
    return this.items.shift();
  }
}

const stringQueue = new Queue<string>();
stringQueue.enqueue("hello");

const numQueue = new Queue<number>();
numQueue.enqueue(10);
```

---

**제네릭으로 쓰는 이유 ?** <br />

- #### ex1 & ex2 - `identity<T> (value: T): T`

  "무슨 값이 들어오든, 그대로 돌려주되 타입 안전하게 만들고 싶어."

  ```tsx
  //제네릭 없는 함수

  function identity(value) {
    return value;
  }
  ```

  이 함수는 `number`든 `string`이든 아무거나 받을 수 있지만, 돌아오는 값의 타입을 알 수가 없음. <br />
  즉, 타입 추론이 안 돼서 `any` 취급받는다.

- #### ex3 - `first<T>(items: T[]): T`

  "배열의 첫 번째 요소를 가져오고 싶은데, 배열의 타입에 따라 반환 타입도 맞춰주고 싶어."

  ```tsx
  function first(arr: any[]) {
    return arr[0]; // 타입 잃어버림
  }
  ```

  → `string[]`, `number[]`, `User[]` … 다 any 취급됨.

- #### ex4 - `pair<K, V>(key: K, value: V): [K, V]`

  "서로 다른 타입 두 개를 묶어서 전달하고 싶어. 근데 각 타입도 잃지 않고 싶어."

  ```tsx
  const pair = ["id", 123]; // string | number[] 가 돼버림
  ```

  ts는 ["id", 123] -> (string | number)[] 즉, `"string 또는 number가 들어갈 수 있는 배열" 이라고 해석함.

- #### ex5 - `type Box<T> = { value: T }`

  "어떤 값을 감싸는 박스 타입을 만들고 싶어. 그 안에 뭐가 들어갈지는 유동적이야."

  ```tsx
  const nameBox: Box<string> = { value: "형규" };
  const ageBox: Box<number> = { value: 33 };
  ```

- #### ex6 - `class Queue<T>`

  "내가 직접 자료구조(큐, 스택, 트리 등)를 만들어 쓰고 싶은데, 그 안에 들어가는 요소 타입을 유연하게 처리하고 싶어."
