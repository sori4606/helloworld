## 유저기능

## 목차

- [쿠키](./유저기능.md#쿠키)
- [인코딩](./유저기능.md#인코딩)
- [인증 (세션, 토큰, 기본)](./유저기능.md#인증)
- [Refresh 토큰](./유저기능.md#refresh-토큰)
- [인증 VS 인가](./유저기능.md#인증-vs-인가)
- [OAuth](./유저기능.md#oauth)
- [Origin](./유저기능.md#origin)
- [CORS](./유저기능.md#cors-cross-origin-resource-sharing)
- [Credential](./유저기능.md#credential)

---

### 쿠키

: 유저 인증뿐만 아니라, 브라우저 이용자에 대한 개인화된 기능과 데이터 제공 수단으로 사용할 수 있다.

ex.

1. 로그인을 하지 않아도 검색기록이 저장됨
2. 쇼핑 카트를 사용할 수 있다거나, 라이트 다크 테마 유지

#### `쿠키 보안 설정`

1. Secure
   : 이 설정을 추가해주면 HTTPS를 사용할 때만 클라이언트에서 서버로 쿠키가 보내짐. <br />
   ex.

   ```javascript
   Set-Cookie: cookie_name=cookie_value; Secure;
   ```

2. HttpOnly
   클라이언트가 자바스크립트 코드로 해당 쿠키에 접근할 수 없게됨. <br />
   ex.

   ```javascript
   Set-Cookie: cookie_name=cookie_value; Secure; HttpOnly;
   ```

3. SameSite

   - Strict: 다른 도메인에서의 모든 요청에서 쿠키 전송 차단
   - Lax: 링크 클릭을 통한 직접 방문시에는 쿠키 전송 허용
   - None: 모든 크로스 사이트 요청에서 쿠키 전송 (Secure 필수)

   CSRF(또는 XSRF) 공격 예방. SameSite를 strict로 하면 다른 도메인에서 리퀘스트를 보낼 때 쿠키가 가는 걸 아예 방지할 수 있음. <br />
   쉽게 이야기해서, 리퀘스트를 보내는 클라이언트와 이걸 받는 서버의 도메인이 서로 같을 때만 쿠키가 간다. <br />

   `문제점?` <br />

   URL을 직접 쳐서 사이트를 방문하기도 하지만, 다른 페이지에 있는 링크를 통해서도 페이지를 방문함 (예를들어, 친구가 메시지로 보낸 링크를 통해서 페이지 방문 -> 이러면 로그인을 또 해야함) <br />
   이때 사용하는 옵션이 Lax, 이 설정을 하면 링크를 통해 사이트를 직접 방문할 때는 쿠키가 보내짐. <br />
   SameSite 설정을 None으로 할 때는 보안 문제 때문에 항상 Secure 옵션을 추가해주어야함. 안해주면 특정 브라우저들은 보안이 취약하다고 판단하고 쿠키를 저장하지 않음.

   ```javascript
   Set-Cookie: cookie_name=cookie_value; Secure; HttpOnly; SameSite=Lax;
   ```

   `궁금한 점` <br />

   : URL을 직접 쳐서 방문하는거랑, 링크를 통해 사이트를 방문하는 거랑 어떻게 구별하지 ? <br />

   답 : 브라우저에서 요청을 분류할 때, 탐색방식과 출처를 보고 판단하는데, **URL 직접 입력**과 **북마크 클릭**은 현재 페이지의 출처가 아니라 아예 **출처 없음 상태**에서 시작함. 그래서 **cross-site**로 보지 않고, **same-site**로 간주한다.

`한눈 비교`

| 옵션     | 목적             | 적용 예시                  | 주의사항              |
| -------- | ---------------- | -------------------------- | --------------------- |
| Secure   | HTTPS에서만 전송 | 로그인 세션 쿠키           | HTTP에서는 동작 안 함 |
| HttpOnly | JS 접근 차단     | 세션 ID 쿠키               | XSS 방어              |
| SameSite | CSRF 방지        | SameSite=Lax로 로그인 유지 | None일 때 Secure 필수 |

### 인코딩

: 데이터를 여러 곳에서 쉽고 안정적이게 사용하기 위해 통일된 형식으로 바꾸는 것.
웹에서는 보통 base64url이 많이 사용됨.

`Base64URL` <br />
Base64 인코딩의 변형으로, URL과 파일명에서 안전하게 사용할 수 있도록 특수문자를 치환한 인코딩 방식.

### 인증

`방식`

### 1. 세션 기반 인증

: 서버가 로그인 정보를 세션으로 저장하고, 클라이언트에 세션 ID를 쿠키로 전달.

`흐름`

1.  사용자 로그인 -> 서버에서 세션 생성
2.  세션 Id를 쿠키에 담아 클라이언트에 전달
3.  클라이언트는 이후 요청 시 쿠키를 자동 전송
4.  서버는 세션 저장소에서 ID 조회 후 사용자 인증

`장점`

- 쿠키 자동 전송 -> 사용자 입장에서 편리
- 인증 로직이 서버 중심이라 관리하기 쉬움
- 탈취당했을 때 바로 서버에서 무효화 가능

`단점`

- 서버에 세션 저장소 필요
- 클라이언트가 많아질 수록 서버 부담 증가

### 2. 토큰 기반 인증

: 인증 후 서버가 토큰(JWT 등)을 발급하고, 클라이언트가 이 토큰을 요청마다 헤더에 포함해서 보냄.

`JWT (JSON Web Token)`
: 인증에 필요한 정보들을 암호화시킨 JSON 토큰. JWT 기반 인증은 JWT 토큰(Access Token)을 HTTP 헤더에 실어 서버가 클라이언트를 식별하는 방식임.

`흐름`

1. 사용자 로그인 -> 서버가 토큰 발급
2. 클라이언트는 로컬스토리지나 세션스토리지에 저장
3. 요청마다 `Authorization: Bearer <token>` 헤더에 포함해서 보냄
4. 서버는 토큰 자체를 검증하고 인증

`장점`

- 서버 상태 저장 필요 없음
- 모바일, SPA(singple page application) 등에서 사용하기 적합
- Restful API 서버를 만들고 있다면, 토큰 기반 인증이 더 적합
- 조금 더 유연하게 사용가능, 효율성 좋음(토큰 자체만 해석하기 때문, 세션기반은 서버랑 항상 비교해야 되기 때문)

`Restful API 서버` : REST 원칙을 따르는 API를 제공하는 서버 <br />
여기서 REST는 HTTP 메서드로 자원에 대한 행동을 정의하는 아키텍처 스타일 (시스템을 어떻게 설계하고 구성할지에 대한 철학)임.

REST 원칙:

- 자원(Resource)은 URI로 표현
- HTTP 메서드로 자원 행위 정의 (GET/POST/PUT/DELETE)
- 무상태성(Stateless)
- 캐싱 가능

  등등..

`단점`

- 토큰 탈취 시 보안 위험
- 토큰 만료/갱신 관리 필요

`유연성` <br />
토큰 기반 인증은 세션 기반 인증보다 조금 더 유연하게 사용될 수 있습니다. 토큰을 발행하는 방법이 똑같고, 시크릿 키만 있으면, 발행을 한 곳과 확인을 하는 곳이 달라도 된다는 말인데요.
예를 들어 같은 유저 데이터베이스를 사용하는 여러 서비스들이 있고, 이 사이트들이 같은 방식과 키를 사용해서 토큰을 발행한다면, 한 사이트에서 제공한 토큰을 가지고 있으면, 다른 서비스가 그걸 해석해서 유저를 파악할 수 있는 거죠. 요즘은 크고 복잡한 웹 애플리케이션들을 더 작은 내용을 담당하는 작은 부분들로 나눠서 개발하는 경우가 많은데요. 이럴 때 토큰을 사용하는 게 훨씬 더 유연하죠.

(코드잇 발췌)

### 3. 기본인증

: HTTP 표준 방식. 매 요청마다 ID/PW를 Base64로 인코딩해서 헤더에 실어서 전송 (요즘엔 거의 안씀)

`흐름`

1. 클라이언트가 `Authorization : Basic <base64(id:pw)>` 헤더로 요청
2. 서버가 이 값을 복호화해서 인증

`장점`

- 간단하고 구현 쉬움
- 별도 세션/토큰 관리 불필요

`단점`

- 매 요청에 ID/PW 전송 -> 보안 매우 취약
- HTTPS 안쓰면 털릴 확률 100%
- 확장성과 유연성이 매우 떨어짐

| 구분        | 세션 기반                   | 토큰 기반                    | 기본 인증        |
| ----------- | --------------------------- | ---------------------------- | ---------------- |
| 저장 위치   | 서버 세션 저장소            | 클라이언트 (localStorage 등) | 매 요청마다 전송 |
| 상태 관리   | Stateful                    | Stateless                    | Stateless        |
| 확장성      | 서버 부담 증가              | 우수                         | 제한적           |
| 보안성      | 높음 (서버에서 즉시 무효화) | 중간 (토큰 탈취 위험)        | 매우 낮음        |
| 사용 편의성 | 자동 쿠키 전송              | 수동 헤더 설정               | 매 요청마다 인증 |
| 적합한 환경 | 전통적인 웹앱               | SPA, 모바일 앱, API          | 간단한 시스템    |

`Stateful` : 서버가 클라이언트의 이전 요청·상태를 저장하고, 다음 요청 처리에 사용함. <br />
클라이언트는 매번 모든 정보를 줄 필요 없음 (서버가 기억하니까). <br />

`Stateless` : 서버가 이전 요청에 대한 정보를 전혀 저장하지 않음. <br />
각 요청은 독립적이며, 필요한 모든 정보를 요청 안에 포함시켜야 함. <br />

### Refresh 토큰

: access 토큰이 소유자가 특정 권한을 가질 수 있게 하는 토큰이라면, refresh 토큰은 이메일과 비밀번호를 사용하지 않고 새로운 access 토큰을 발급받을 수 있게 하는 토큰

| 구분        | Access Token                 | Refresh Token       |
| ----------- | ---------------------------- | ------------------- |
| 역할        | API 접근 권한 부여           | Access Token 재발급 |
| 수명        | 짧음 (분\~시간)              | 김 (일\~개월)       |
| 저장 위치   | 클라이언트 (메모리/스토리지) | 보안 저장소         |
| 보안 중요도 | 높음                         | 매우 높음           |

`동작 흐름`

1. 로그인 ( Access Token + Refresh Token 발급)
2. Access Token 만료 ( 클라이언트가 서버에 Refresh Token으로 재발급 요청)
3. Access Token 재발급 ( 서버가 Refresh Token 겁증 후, 새로운 Access Token 반환. [재 로그인 없이, 자동갱신] )

### `인증` VS `인가`

인증 : 너 누구냐 ? <br />

: 사용자가 진짜로 주장하는 사람인지 확인하는 절차 <br />
(ex. 로그인 창에서 아이디 비밀번호 입력)

인가 : 그래서 너, 이거 해도 돼 ?

: 인증된 사용자가 특정 리소스에 접근할 권한이 있는지 확인 <br />
(ex. 일반 사용자는 admin 못들어감. 게시글을 쓴 유저만 수정/삭제 가능)

| 구분 | 인증 (Authentication)    | 인가 (Authorization)                 |
| ---- | ------------------------ | ------------------------------------ |
| 질문 | "너 누구냐?"             | "너, 이거 해도 돼?"                  |
| 목적 | 신원 확인                | 권한 확인                            |
| 예시 | 로그인 (아이디/비밀번호) | 관리자 페이지 접근, 게시글 수정 권한 |
| 시점 | 최초 접근 시             | 리소스 접근 시마다                   |

### OAuth

: 제3자 앱이 사용자 대신 다른 서비스의 자원에 접근할 수 있게 해주는 권한 위임 프로토콜. 로그인 또는 API 접근 등에 사용됨.

OAuth에 `Implicit 플로우`, `Authorization Code 플로우`, `Hybrid 플로우`, `Client-Credentials 플로우` 등 많지만, `Authorization Code 플로우`를 주로 사용함.

#### `Authorization Code Flow`

`흐름`

1. 유저 로그인 -> Authorization Code만 브라우저에 전달
2. 클라이언트 서버가 이 코드를 이용해 Access Token을 서버에서 안전하게 요청
3. 클라이언트는 이 토큰으로 사용자 리소스 접근

`장점`

- Access Token이 브라우저에 직접 노출되지 않음
- Refresh Token 사용가능
- 요즘은 PKCE까지 붙여서 클라이언트 단에서도 안전하게 사용 가능 <br />
  PKCE (Proof Key for Code Exchange): 인증 코드 탈취를 막기 위한 추가 보안 장치. 클라이언트에서 랜덤한 값을 생성하여 OAuth 플로우에 추가하는 방식.

`전체 흐름 요약 예시` <br />

[1] 사용자가 로그인 버튼 클릭 <br />
↓ <br />
[2] 특정 앱 → 구글(네이버, 카카오 등) 로그인 페이지로 리다이렉트 <br />
↓ <br />
[3] 사용자 로그인 후, 구글이 "Authorization Code"를 특정 앱에 전달 (브라우저 URL) <br />
↓ <br />
[4] 특정 앱 서버는 이 코드를 구글에 전송해 Access Token + Refresh Token 요청 <br />
↓ <br />
[5] 구글 → 특정 앱 서버에 Access Token + Refresh Token 발급 <br />
↓ <br />
[6] Access Token으로 유저 정보 등 요청 가능 <br />
↓ <br />
[7] Access Token 만료 시 → Refresh Token으로 새로운 Access Token 재발급 <br />
<br />

### Origin

: 웹에서 요청을 보내는 출처를 나타내는 개념. 다음 3가지 요소로 구성됨.

- 프로토콜 (Protocol) : http, https
- 도메인 (Domain) : example.com, localhost
- 포트 (Port) : 80,443,3000 등

이 세 가지 요소 중 하나라도 다르면 다른 Origin으로 간주됨.

### CORS (Cross-Origin Resource Sharing)

: CORS는 브라우저의 보안 정책 중 하나로, 다른 Origin에서 리소스에 접근하는 것을 제어하는 메커니즘이다.

#### 왜 CORS가 필요한가 ?

: 브라우저에는 Same-Origin Policy(동일 출처 정책)라는 보안 정책이 있는데, 이는 악의적인 웹사이트가 사용자 모르게 다른 사이트의 데이터에 접근하는 것을 방지함.

예시 상황 :

```
사용자가 https://bank.com에 로그인한 상태에서
악의적인 사이트 https://evil.com을 방문했다고 가정

만약 Same-Origin Policy가 없다면:
evil.com에서 JavaScript로 bank.com의 API를 호출해서
사용자의 계좌 정보를 몰래 가져올 수 있음
```

#### CORS는 언제 발생하나 ?

1. 프론트엔드와 백엔드가 다른 도메인

   프론트: `https://myapp.com`
   백엔드: `https://api.myapp.com`

2. 개발 환경에서 포트가 다를 때

   프론트: `http://localhost:3000`
   백엔드: `http://localhost:8080`

3. 외부 API 호출

   내 사이트: `https://mysite.com`
   외부 API: `https://api.external.com`

#### CORS 해결 방법

1. CORS 헤더 설정

```jsx
export async function GET() {
  const data = await fetchFromExternalAPI();

  return new Response(JSON.stringify(data), {
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
    },
  });
}
```

프론트엔드에서 사용 :

```jsx
// 컴포넌트에서
useEffect(() => {
  // 같은 도메인이므로 CORS 문제 없음
  fetch("/api/users")
    .then((res) => res.json())
    .then((data) => setUsers(data));
}, []);
```

2. 프록시 서버 사용

: 개발 환경에서 프록시를 설정해서 같은 Origin으로 만들기

프록시 : 중간에서 요청을 대신 전달해주는 서버

프록시 없이

```
브라우저 (http://localhost:3000)
    ↓ 직접 요청
API 서버 (http://localhost:8080)
❌ CORS 에러! (다른 포트이므로)
```

프록시 사용 (CORS 문제 해결)

```
브라우저 (http://localhost:3000)
    ↓ 같은 도메인으로 요청
프록시 서버 (http://localhost:3000/api)
    ↓ 서버끼리 통신 (CORS 제약 없음)
API 서버 (http://localhost:8080)
✅ 성공!
```

- 서버 간 통신에는 CORS 제약이 없음

next.config.js에서 프록시 설정

```javascript
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  async rewrites() {
    return [
      {
        source: "/api/:path*",
        destination: "http://localhost:8080/api/:path*", // 프록시 대상
      },
    ];
  },
};

module.exports = nextConfig;
```

프론트엔드에서,

```jsx
// /api/users 요청이 자동으로 http://localhost:8080/api/users로 프록시됨
fetch("/api/users"); // ✅ CORS 문제 없음
```

3. CORS 미들웨어 사용

```javascript
// Express + cors 미들웨어
const cors = require("cors");
app.use(
  cors({
    origin: "https://myapp.com",
    credentials: true,
  })
);
```

#### 주요 CORS 헤더들

- **Access-Control-Allow-Origin**: 허용할 Origin
- **Access-Control-Allow-Methods**: 허용할 HTTP 메서드
- **Access-Control-Allow-Headers**: 허용할 헤더
- **Access-Control-Allow-Credentials**: 쿠키 포함 여부
- **Access-Control-Max-Age**: Preflight 결과 캐시 시간

### Credential

: 자격, 증명서. <br />
사용자의 신원을 증명하는 모든 종류의 정보. <br />
웹 개발에서는 <br />

- 아이디 / 비밀번호 : 가장 기본적인 인증 정보
- JWT 토큰 : 서버에서 발급한 인증 토큰
- 쿠키 : 브라우저에 저장되는 인증 정보 (세션 ID, 토큰 등)
- API 키 : 서비스 접근을 위한 키

#### Axios에서 withCredentials 사용 예시

```javascript
// 1. 기본 설정 - 쿠키가 전송되지 않음
axios
  .get("https://api.example.com/user")
  .then((response) => console.log(response.data));

// 2. withCredentials: true - 쿠키가 함께 전송됨
axios
  .get("https://api.example.com/user", {
    withCredentials: true,
  })
  .then((response) => console.log(response.data));

// 3. 전역 설정으로 모든 요청에 적용
axios.defaults.withCredentials = true;

// 4. 인스턴스 생성시 설정
const apiClient = axios.create({
  baseURL: "https://api.example.com",
  withCredentials: true,
});
```

#### Fetch API의 credentials 옵션

```javascript
// 1. omit - 쿠키를 절대 보내지 않음
fetch("https://api.example.com/data", {
  credentials: "omit",
}).then((response) => response.json());

// 2. same-origin (기본값) - 같은 Origin일 때만 쿠키 전송
fetch("https://myapp.com/api/data", {
  credentials: "same-origin", // 기본값이라 생략 가능
}).then((response) => response.json());

// 3. include - 항상 쿠키 전송 (Cross-Origin에서도)
fetch("https://api.example.com/data", {
  credentials: "include",
}).then((response) => response.json());
```

실제 사용 예시

ex1. 로그인 후 인증이 필요한 API 호출

```javascript
// 로그인 요청
const login = async (username, password) => {
  const response = await axios.post(
    "https://api.example.com/login",
    {
      username,
      password,
    },
    {
      withCredentials: true, // 서버에서 Set-Cookie로 세션 쿠키를 보내면 저장됨
    }
  );

  return response.data;
};

// 이후 인증이 필요한 API 호출
const getUserProfile = async () => {
  const response = await axios.get("https://api.example.com/profile", {
    withCredentials: true, // 저장된 쿠키가 자동으로 전송됨
  });

  return response.data;
};
```

ex2. JWT 토큰 사용

```javascript
// JWT를 쿠키에 저장하는 경우
const apiCall = async () => {
  const response = await fetch("https://api.example.com/protected", {
    method: "GET",
    credentials: "include", // JWT 쿠키가 자동으로 전송됨
    headers: {
      "Content-Type": "application/json",
    },
  });

  return response.json();
};

// JWT를 헤더에 직접 넣는 경우 (credentials 설정 불필요)
const token = localStorage.getItem("jwt");
const response = await fetch("https://api.example.com/protected", {
  method: "GET",
  headers: {
    Authorization: `Bearer ${token}`,
    "Content-Type": "application/json",
  },
});
```
