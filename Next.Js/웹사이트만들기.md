## Next.js로 웹사이트 만들기

### `<Link>` 컴포넌트

: Next에서는 `<a>` 태그 대신에 `<Link>` 컴포넌트를 사용한다. 내부적으로 여러 가지 최적화를 해주기 떄문에 빠르고 부드러운 페이지 전환이 가능. 내부 라우팅 전용임. <br />

- 내부 경로 → `<Link href="/products">Products</Link>`

- 외부 링크 → `<a href="https://example.com" target="_blank" rel="noreferrer">공식 사이트</a>` <br />

### `다양한 옵션들`

#### `prefetch`

- 기본값 : `true`
- **역할** : 링크가 화면에 보이면 해당 페이지를 미리 로드
- **효과** : 클릭 시 즉시 페이지 전환

언제 `prefetch = {false}`를 사용할까 ?

- 사용자가 자주 방문하지 않는 페이지
- 데이터 사용량을 줄이고 싶을 때
- 무거운 페이지

#### `replace`

- 기본값 : `false`
- **역할** : 뒤로가기 스택이 쌓임
- **효과** : 페이지 기록 남기기 (기본값) vs 현재 페이지 기록을 새 페이지로 교체

언제 `replace={true}`를 사용할까 ?

- 로그인 후 대시보드 이동
- 404 페이지에서 홈으로 리다이렉트
- 임시 페이지에서 최종 페이지로 이동

#### `scroll`

- 기본 값 : `true`
- **역할** : 이동 시 스크롤 위치 제어
- **효과** : 페이지 전환 후 맨 위로 스크롤 (기본값) vs 현재 위치 유지

언제 `scroll={false}`를 사용할까 ?

- 탭 전환 시 (같은 페이지 내 콘텐츠만 변경)
- 페이지네이션
- 필터링/정렬
- 쿼리스트링만 변경되는 경우

ex.

```jsx
// 미리 로드 O (기본값)
<Link href="/about">About</Link>
// 미리 로드 X (클릭 시에만 로드)
<Link href="/about" prefetch={false}>About</Link>

// 일반 이동 (뒤로가기 가능)
<Link href="/dashboard">대시보드</Link>
// 히스토리 대체 (뒤로가기 불가)
<Link href="/dashboard" replace>대시보드</Link>

// 맨 위로 스크롤 (기본값)
<Link href="/about">About</Link>
// 스크롤 위치 유지
<Link href="/about" scroll={false}>About</Link>
```

### `useRouter()` Hook

: Pages router 에서는 `router.query` 값을 사용하면 페이지 주소에서 `Params` 값이나 쿼리스트링 값을 참조할 수 있음. (CSR 이기 때문에 가능 ! ) <br />

ex. (Pages Router) - useRouter 사용

```jsx
import { useRouter } from "next/router";

export default function Product() {
  const router = useRouter();
  const id = router.query["id"]; // 브라우저에서 URL 파싱 가능

  return <>Product #{id} 페이지</>;
}
```

ex2. 티셔츠에 해당하는 값 가져오기 (Pages Router) - useRouter 사용

```jsx
import { useRouter } from "next/router";

export default function Search() {
  const router = useRouter();
  const q = router.query["q"];

  return <>{q} 검색 결과</>;
}
```

ex3. 페이지 이동하기 (Pages Router) - `router.push()`

```jsx
import { useRouter } from "next/router";

export default function HomePage() {
  const router = useRouter();

  const handleClick = () => {
    router.push("/products");
  };

  return <button onClick={handleClick}>상품 페이지로 이동</button>;
}
```

#### `App Router` 에서는 어떻게 사용하나 ?

ex. (App Router) - params 사용

```jsx
// app/products/[id]/page.js
export default function Product({ params }) {
  // 서버에서 미리 파싱된 params를 props로 받음
  return <div>Product {params.id}</div>;
}
```

ex2. 티셔츠에 해당하는 값 가져오기 (App Router) - useSearchParams 사용

```jsx
"use client";
import { useSearchParams } from "next/navigation";

export default function Search() {
  const searchParams = useSearchParams();
  const q = searchParams.get("q");

  return <>{q} 검색 결과</>;
}
```

ex3. 페이지 이동하기 (App Router) - `router.push()`

```jsx
"use client";
import { useRouter } from "next/navigation";

export default function HomePage() {
  const router = useRouter();

  const handleClick = () => {
    router.push("/products");
  };

  return <button onClick={handleClick}>상품 페이지로 이동</button>;
}
```

정리하자면, `useRouter()` Hook 은 Pages Router, App Router 에서 모두 사용할 수 있지만, Pages Router 에서만 `router.query` 를 쓸 수 있고, App Router 에서는 `router.query` 는 쓸 수 없지만, `router.push('/home')` , `router.back()` , `router.refresh()` 와 같은 페이지 이동으로 쓴다.

여기서, `'use client'` 는 뭐지 ? <br />

Pages Router 의 모든 컴포넌트가 기본적으로 클라이언트 컴포넌트라서, `'use client'` 가 불필요하다. 왜 ? 이미 클라이언트단에서 실행되기 때문. <br />

그런데, App Router 는 모든 컴포넌트가 기본적으로 서버 컴포넌트라서 Hook을 사용하려면 `'use client'` 를 써줘야한다. <br />

필요한경우는

- Hook 사용 (`useState`, `useEffect`, `useRouter` 등)
- 이벤트 핸들러 (`onClick`, `onChange` 등)
- 브라우저 전용 API (`localStorage`, `window` 등)

결론 : `'use client'`는 App Router에서 상호작용이 필요한 컴포넌트에만 사용하는 특별한 지시문이다 !

### 리다이렉트

next.config.js 에서 `redirects()` 함수를 정의하면 특정 주소에 대해서 리다이렉트할 주소를 지정할 수 있다.

ex.

공통 (next.config.js)

```js
// next.config.js
module.exports = {
  async redirects() {
    return [
      {
        source: "/old-page",
        destination: "/new-page",
        permanent: true, // 301 리다이렉트
      },
    ];
  },
};
```

**Pages Router**

```jsx
// pages/api나 getServerSideProps에서
import { redirect } from "next/navigation"; // ❌ 사용 불가

// getServerSideProps에서 리다이렉트
export async function getServerSideProps() {
  return {
    redirect: {
      destination: "/login",
      permanent: false,
    },
  };
}
```

**App Router**

```jsx
// app/dashboard/page.js
import { redirect } from "next/navigation";

export default function Dashboard() {
  const user = getCurrentUser();

  if (!user) {
    redirect("/login"); // 서버에서 리다이렉트
  }

  return <div>대시보드</div>;
}
```

### 커스텀 404 페이지

#### 언제 404 페이지가 나타날까 ?

1. 존재하지 않는 URL 접근 : `/존재하지않는페이지`
2. 삭제된 게시물 : `/posts/999999` (없는 게시물 ID)
3. 잘못된 경로 : `/blgo/my-post` (오타)
4. 권한이 없는 페이지 : 로그인이 필요한데 비로그인 상태

| 구분             | 구현 위치                               | 특징                                     |
| ---------------- | --------------------------------------- | ---------------------------------------- |
| **Pages Router** | `pages/404.js`                          | 자동으로 404 라우트에 매핑               |
| **App Router**   | `app/not-found.tsx` + `notFound()` 함수 | 라우트별로 호출 가능, 전역 404 역할도 함 |

#### Pages Router

#### 📁 기본 구조

```
pages/
├── index.js          # 홈페이지
├── about.js          # /about 페이지
├── 404.js            # 커스텀 404 페이지 ⭐
└── posts/
    └── [id].js       # 동적 라우트
```

```jsx
// pages/404.js
export default function Custom404() {
  return <h1>이 페이지는 존재하지 않습니다.</h1>;
}
```

#### 특징

- ✅ 간단함: 파일만 만들면 끝
- ✅ 자동 매핑: Next.js가 알아서 404 상황에 보여줌
- ❌ 한계: 전역 404만 가능 (특정 조건부 404 어려움)

#### App Router

#### 📁 기본 구조

```
app/
├── page.tsx           # 홈페이지
├── about/
│   └── page.tsx      # /about 페이지
├── not-found.tsx     # 전역 404 페이지 ⭐
└── blog/
    ├── [id]/
    │   ├── page.tsx  # 블로그 상세 페이지
    │   └── not-found.tsx  # 블로그 전용 404 페이지 ⭐
    └── page.tsx      # 블로그 목록
```

#### 전역 404 페이지

```jsx
// app/not-found.tsx
export default function NotFound() {
  return <h1>404 - 페이지를 찾을 수 없습니다.</h1>;
}
```

#### 조건부 404 처리

```jsx
// app/blog/[id]/page.tsx
import { notFound } from "next/navigation";

// 가상의 블로그 데이터
const blogPosts = [
  { id: "1", title: "첫 번째 글", content: "안녕하세요!" },
  { id: "2", title: "두 번째 글", content: "반갑습니다!" },
];

export default function BlogPost({ params }: { params: { id: string } }) {
  // 블로그 포스트 찾기
  const post = blogPosts.find((p) => p.id === params.id);

  // 포스트가 없으면 404 페이지 보여주기
  if (!post) {
    notFound(); // 🎯 이게 핵심!
  }

  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  );
}
```

#### 블로그 전용 404 페이지

```tsx
// app/blog/[id]/not-found.tsx
import Link from "next/link";

export default function BlogNotFound() {
  return (
    <div className="text-center py-16">
      <h1 className="text-4xl font-bold mb-4">📝 블로그 글을 찾을 수 없어요</h1>
      <p className="text-gray-600 mb-8">
        요청하신 블로그 글이 삭제되었거나 존재하지 않습니다.
      </p>
      <div className="space-x-4">
        <Link
          href="/blog"
          className="bg-green-500 text-white px-6 py-2 rounded hover:bg-green-600"
        >
          다른 블로그 글 보기
        </Link>
        <Link
          href="/"
          className="bg-gray-500 text-white px-6 py-2 rounded hover:bg-gray-600"
        >
          홈으로 가기
        </Link>
      </div>
    </div>
  );
}
```

- Pages Router → 전역 404 페이지만 가능.
- App Router → 전역 + 특정 라우트에서 조건부로 404 처리 가능.

### google font 적용하기

ex.

```jsx
// pages/_app.js에서 또는 app/layout.js에서

import { Noto_Sans_KR } from "@next/font/google";

const notoSansKR = Noto_Sans_KR({
  weight: ["400", "700"],
  subsets: [],
});
```

weight은 폰트 굵기, subsets은 폰트에서 영문, 한글 이런 식으로 사용할 글자들만 골라서 사용할 때 쓰는 건데, 빈 배열은 전부 다 사용하는 거. <br />
만약 영문만 사용하는 폰트면 `['latin']`

`적용 시`

```jsx
<main className={notoSansKR.className}>

// OR
//넥스트에서 제공하는 <Head> 컴포넌트
<Head>
  <style>{`
    html {
      font-family: ${notoSansKR.style.fontFamily}, sans-serif;
    }
  `}</style>
</Head>
```

### `<Image>` 컴포넌트

: Next.js 서버를 한번 거쳐서 이미지 최적화를 한 다음 사용할 수 있도록 해줌. <br />
반드시 크기가 있어야한다 ! width와 height값을 지정하거나 fill이라는 Prop 사용

ex1. `width` , `height` 사용하기

```jsx
import Image from "next/image";

export default function Page() {
  return (
    <>
      <Image
        src="/images/product.jpeg"
        width={300}
        height={300}
        alt="상품 이미지"
      />
    </>
  );
}
```

ex2. cover 사용 (부모 요소에 relative 필수)

```jsx
import Image from "next/image";

export default function Page() {
  return (
    <>
      <div
        style={{
          position: "relative",
          width: "100%",
          height: "300px",
        }}
      >
        <Image
          src="/images/product.jpeg"
          fill
          alt="상품 이미지"
          style={{
            objectFit: "cover",
          }}
        />
      </div>
    </>
  );
}
```

### `<Head>` 컴포넌트

: 기본 HTML의 `<head>`안에 들어가는 내용들 ( `<title>` : 페이지 제목, `<meta>` : SEO, 소셜 미디어 미리보기 등 , `<link>` : 폰트, 파비콘 등 외부 리소스 링크)
을 컴포넌트 형태로 선언적으로 (JSX 문법) 관리할 수 있게 해주는 컴포넌트.
렌더링된 페이지의 `<head>` 안에 내용을 쓸 수 있음.

#### 장점

1. SEO 최적화 : 페이지마다 다른 `<title>`과 `<meta>` 설정 가능
2. SNS 공유 : og:title, og:image 등 Open Graph 태그 쉽게 삽입

### 프리 렌더링

: 웹 페이지가 페이지를 로딩하기 이전에 렌더링하는 걸 말함. <br />
크게 **정적 생성**과 **서버 사이드 렌더링**으로 나뉨. Next.js에서는 기본적으로 모든 페이지를 정적 생성함.

### 정적 생성

: 프로젝트를 빌드하는 시점에 미리 HTML을 렌더링하는 걸 말함.

#### `getStaticProps()` 함수 (Pages router)

: 정적 생성할 때 필요한 데이터를 받아와서 렌더링하고 싶을 때 이 함수를 구현하고 export 하면 됨. <br />
객체의 props 프로퍼티로 넘겨줄 Props 객체를 지정하고, 이것을 페이지 컴포넌트에서 사용할 수 있음. <br />
context 파라미터를 사용해서 필요한 Params 값이나 쿼리스트링 값을 참조할 수 있음. <br />
한줄정리 : **경로별 데이터 제공**

ex.

```jsx
export async function getStaticProps() {
  console.log("빌드 시점에 실행됨!"); // 브라우저가 아닌 서버에서 실행

  const res = await axios("/products/");
  const products = res.data;

  // 이 객체를 페이지 컴포넌트에게 전달
  return {
    props: {
      products, // products: products 의 축약형 (키: 값)
    },
  };
}

// 📦 Next.js가 위에서 return한 props를 여기로 전달해줌
export default function Home({ products }) {
  //                          ↑ 여기서 받는 products는
  //                            위의 props.products가 전달된 것!
  return <ProductList products={products} />;
}
```

번외) 키 : 값 형태 더 자세하게 살펴보기.

```jsx
export async function getStaticProps() {
  const res = await axios("/products/");
  const productData = res.data; // 변수명을 다르게 해보면

  return {
    props: {
      products: productData, // 키이름: 변수명 (다름)
      // 또는
      productData: productData, // 키이름: 변수명 (같음)
      // 축약하면
      productData, // productData: productData 의 축약
    },
  };
}
```

다른 예시로는.

```jsx
const userName = "김철수";
const userAge = 25;
const userEmail = "kim@email.com";

// 원래 방식
const userObj = {
  userName: userName,
  userAge: userAge,
  userEmail: userEmail,
};

// 축약 방식
const userObj = {
  userName, // userName: userName
  userAge, // userAge: userAge
  userEmail, // userEmail: userEmail
};

// 둘 다 같은 결과:
// { userName: "김철수", userAge: 25, userEmail: "kim@email.com" }
```

#### `notFound` 옵션

#### 언제사용 ?

- API에서 데이터를 못 가져왔을 때
- 존재하지 않는 상품/게시글에 접근했을 때
- 권한이 없는 페이지에 접근했을 때

ex.

```jsx
export async function getStaticProps({ params }) {
  const productId = params.id;

  try {
    const res = await fetch(`https://api.example.com/products/${productId}`);

    if (!res.ok) {
      // API 응답이 실패하면 404 처리
      return { notFound: true };
    }

    const product = await res.json();

    // 상품이 삭제되었거나 비활성 상태면 404
    if (!product || product.status === "deleted") {
      return { notFound: true };
    }

    return {
      props: { product },
    };
  } catch (error) {
    console.error("상품 로딩 실패:", error);
    return { notFound: true };
  }
}
```

ex2. fallback과의 관계

```jsx
// getStaticPaths.js
export async function getStaticPaths() {
  return {
    paths: [{ params: { id: "1" } }, { params: { id: "2" } }],
    fallback: true, // 또는 'blocking'
  };
}

// getStaticProps.js
export async function getStaticProps({ params }) {
  const product = await fetchProduct(params.id);

  // fallback: true일 때, 존재하지 않는 상품이면 404
  if (!product) {
    return { notFound: true };
  }

  return { props: { product } };
}

// 페이지 컴포넌트
export default function ProductPage({ product }) {
  const router = useRouter();

  // fallback: true일 때 로딩 상태 처리
  if (router.isFallback) {
    return <div>로딩 중...</div>;
  }

  return <div>상품: {product.name}</div>;
}
```

#### `revalidate 옵션`

```jsx
return {
  props: { product },
  revalidate: 3600, // 1시간 = 3600초마다 최신화
};
```

ISR (Incremental Static Regeneration) 을 위한 옵션. 지정한 초 단위마다 정적 페이지를 백그라운드에서 재생성해 최신 데이터 반영. <br />

`언제씀 ?` <br />

: 정적 페이지의 속도 + 최신성을 둘 다 잡고 싶을 때. 콘텐츠가 가끔 바뀌는 경우 (블로그, 마케팅 페이지 등)

실무 사용 사례 <br />

```jsx
// 블로그 포스트 (하루에 한 번 업데이트)
export async function getStaticProps() {
  const posts = await getBlogPosts();

  return {
    props: { posts },
    revalidate: 86400, // 24시간 = 86400초
  };
}

// 상품 목록 (30분마다 재고/가격 업데이트)
export async function getStaticProps() {
  const products = await getProducts();

  return {
    props: { products },
    revalidate: 1800, // 30분 = 1800초
  };
}

// 뉴스 피드 (5분마다 업데이트)
export async function getStaticProps() {
  const news = await getLatestNews();

  return {
    props: { news },
    revalidate: 300, // 5분 = 300초
  };
}
```

#### `redirect 옵션`

: 조건에 따라 특정 경로로 리다이렉트 가능.

```jsx
export async function getStaticProps({ params }) {
  const user = await getCurrentUser();

  // 로그인하지 않은 사용자는 로그인 페이지로
  if (!user) {
    return {
      redirect: {
        destination: "/login",
        permanent: false, // 302 (임시 리다이렉트)
      },
    };
  }

  return {
    props: { user },
  };
}
```

permanent 옵션의 차이

```jsx
// 임시 리다이렉트 (302) - 나중에 돌아올 수 있음
return {
  redirect: {
    destination: "/maintenance",
    permanent: false,
  },
};

// 영구 리다이렉트 (301) - SEO에 영향, 검색엔진이 새 URL을 기억함
return {
  redirect: {
    destination: "/new-product-page",
    permanent: true,
  },
};
```

### getStaticPaths() (Pages router)

: 다이나믹 라우팅을 하는 페이지를 정적 생성할 때에는 어떤 페이지를 정적 생성할지 지정해줘야 하는데, getStaticPaths()라는 함수를 구현하고 export 해서 정해줄 수 있음. <br />
paths라는 배열에서 각 페이지에 해당하는 정보를 넘겨줄 수 있음. fallback 이라는 속성을 사용해서 정적 생성되지 않은 페이지를 처리해 줄 것인지 지정할 수 있는데, fallback: true 라고하면 생성되지 않은 페이지로 접속했을 때 getStaticProps() 함수를 실행해 페이지를 만들어서 보여줌. <br />
한줄정리 : **정적 생성 대상 경로 지정**

#### `fallback` 옵션

- `false` : 지정한 paths만 정적으로 생성, 나머지는 404

- `true` : 빈 페이지 먼저 보여주고 → 데이터 로딩 → 완성된 페이지

- `'blocking'` : 서버에서 완전히 생성될 때까지 기다림 → 완성된 페이지 바로 보여줌

ex.

```jsx
export async function getStaticPaths() {
  return {
    paths: [{ params: { id: "1" } }, { params: { id: "2" } }],
    fallback: true,
  };
}
```

#### 실무 팁

- paths를 전부 나열하지 않고, API에서 동적으로 가져와서 자동 생성하는 경우가 많음.

- 너무 많은 paths를 한 번에 빌드하면 빌드 타임이 폭발적으로 늘어나므로, 핵심 페이지만 지정하고 나머지는 fallback: 'blocking'으로 처리하는 게 효율적임.

```jsx
export async function getStaticPaths() {
  const res = await fetch("/products");
  const products = await res.json();

  // 인기 상품 100개만 미리 생성
  const paths = products
    .slice(0, 100)
    .map((p) => ({ params: { id: p.id.toString() } }));

  return {
    paths, //빌드 시 미리 생성할 페이지들
    fallback: "blocking", // 나머지 페이지는 요청 시 생성
  };
}
```

#### 언제 사용할까 ? (`getStaticPaths` vs `getStaticProps`)

- getStaticProps : 빌드 시 데이터를 미리 fetch해서 정적 페이지 생성

- getStaticPaths : 동적 라우트([id].js)에서 빌드 시 생성할 페이지들 지정

### 서버사이드 렌더링 (SSR)

: 서버에 리퀘스트가 도착할 때마다 페이지를 렌더링해서 보내주는 방식. <br />
getServerSideProps() 함수를 구현하고 export 하면 됨. <br />
props 프로퍼티로 Props 객체를 넘겨주면 페이지 컴포넌트에서 받아서 사용할 수 있음.

ex.

```jsx
export async function getServerSideProps() {
  const res = await axios("/products/");
  const products = res.data;

  return {
    props: {
      products,
    },
  };
}

export default function Home({ products }) {
  return <ProductList products={products} />;
}
```

### - 정적 생성 VS 서버 사이드 렌더링(SSR)

Next.js에서는 특별한 경우가 아니라면 정적 생성으로 구현할 것을 권장. <br />

(왜 ? -> 리퀘스트가 들어올 때마다 매번 렌더링을 하는 것보다 미리 렌더링을 해서 저장해 둔 것을 보내 주는 게 훨씬 빠름)

SSR을 쓰면 좋은 경우는 ?

1. 항상 최신 데이터를 보여 줘야 하는 경우
2. 데이터가 자주 바뀌는 경우
3. 리퀘스트의 데이터를 사용해야 하는 경우.

### `App Router` vs `Pages Router` 표로 비교하기

| 기능                  | Pages Router        | App Router          |
| --------------------- | ------------------- | ------------------- |
| **라우팅 파일**       | `파일명.js`         | `page.js`           |
| **매개변수 가져오기** | `useRouter().query` | `params` prop       |
| **쿼리스트링**        | `useRouter().query` | `useSearchParams()` |
| **레이아웃**          | `_app.js`           | `layout.js`         |
| **로딩 UI**           | 직접 구현           | `loading.js`        |
| **에러 처리**         | `_error.js`         | `error.js`          |

#### 각 기능별 설명

**라우팅 파일**

- Pages Router: 파일명이 곧 URL 경로 (`about.js` → `/about`)
- App Router: 폴더명이 URL, `page.js`가 실제 페이지 (`about/page.js` → `/about`)

**매개변수 가져오기**

- Pages Router: `useRouter()` Hook으로 query 객체에서 추출
- App Router: 서버 컴포넌트에서 `params` prop으로 자동 전달

**쿼리스트링**

- Pages Router: 매개변수와 동일하게 `router.query`에서 처리
- App Router: 별도의 `useSearchParams()` Hook 사용

**레이아웃**

- Pages Router: 전역 `_app.js`에서 공통 레이아웃 처리
- App Router: 각 경로별로 `layout.js` 파일로 중첩 레이아웃 지원

**로딩 UI**

- Pages Router: 개발자가 직접 로딩 상태 구현 필요
- App Router: `loading.js` 파일만 만들면 자동으로 로딩 UI 처리 (해당 세그먼트가 데이터를 패칭하는 동안 로딩 UI가 뜸)

**에러 처리**

- Pages Router: `_error.js`에서 전역 에러 처리
- App Router: `error.js` 파일로 각 경로별 에러 경계 자동 생성

### `Pages Router` vs `App Router` 상세 비교하기

#### 📁 폴더 구조 비교

`Pages Router` (pages 폴더에 페이지 컴포넌트들을 추가함.)

```
pages/
  index.js          → /
  about.js          → /about
  products/
    index.js        → /products
    [id].js         → /products/123
  api/
    hello.js        → /api/hello
```

`App Router` (app 폴더에 페이지 컴포넌트들을 추가함.)

```
app/
  page.js           → /
  about/page.js     → /about
  products/
    page.js         → /products
    [id]/page.js    → /products/123
  api/hello/route.js → /api/hello
```

#### 🔄 데이터 패칭 비교

`Pages Router` : 복잡한 함수들 (`getStaticProps` , `getServerSideProps` 등)

```jsx
// 정적 생성
export async function getStaticProps() {
  const data = await fetch("/api/data");
  return { props: { data } };
}

// 서버사이드 렌더링
export async function getServerSideProps() {
  const data = await fetch("/api/data");
  return { props: { data } };
}

export default function Page({ data }) {
  return <div>{data}</div>;
}
```

`App Router` : 간단한 async/await

```jsx
// 서버 컴포넌트에서 직접 데이터 패칭
async function getData() {
  const res = await fetch("/api/data");
  return res.json();
}

export default async function Page() {
  const data = await getData(); // 🎉 함수 최상위에서 바로!
  return <div>{data}</div>;
}
```

#### 🖥️ 렌더링 방식 차이

`Pages Router`

- 기본 : 클라이언트 컴포넌트 (브라우저에서 렌더링)
- 서버 렌더링하려면 `getServerSideProps` 필요

`App Router`

- 기본 : 서버 컴포넌트 (서버에서 렌더링)
- 클라이언트 컴포넌트 사용하려면 `'use client'` 명시

#### 🛣️ API Routes 비교

`Pages Router`

```js
// pages/api/hello.js
export default function handler(req, res) {
  if (req.method === "GET") {
    res.status(200).json({ message: "Hello" });
  } else {
    // Handle any other HTTP method
  }
}
```

`App Router`

app/api/route.ts -> api 경로를 처리할 핸들러 (서버 전용)

```js
// app/api/hello/route.js
export async function GET(request) {
  return new Response(JSON.stringify({ message: "Hello" }));
}

export async function POST(request) {
  return new Response("Created", { status: 201 });
}
```

-> 클라이언트에서 fetch('/api/hello') 하면 이 코드가 실행됨.
-> GET, POST, PUT 등 HTTP 메서드 함수로 구분해서 정의.

#### 💡 주요 장점 비교

App Router가 더 좋은 점 :

- ✅ 간단한 데이터 패칭: `getStaticProps` 등 복잡한 함수 불필요. async/await 으로 간단하게.
- ✅ 서버 컴포넌트 기본: 더 빠른 로딩, 작은 번들 사이즈
- ✅ 직관적인 폴더 구조: `page.js`, `layout.js` 명확한 역할
- ✅ 스트리밍: 페이지를 점진적으로 로딩 가능

Pages Router가 더 좋은 점 :

- ✅ 성숙한 생태계: 더 많은 자료와 예시
- ✅ 명확한 렌더링 구분: `getStaticProps`, `getServerSideProps`로 명시적
